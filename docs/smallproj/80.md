# 248 号

> 原文：<http://inventwithpython.com/bigbookpython/project79.html>

![](img/9d995d63aaead72cad01120081eb8f75.png)

网络开发者 Gabriele Cirulli 在一个周末就发明了游戏 2048。它的灵感来自于 Veewo 工作室的 1024 游戏，而这个游戏的灵感又来自于 Threes！，开发团队 Sirvo 的一款游戏。2048 年，你必须在一个 4 × 4 的板上合并数字，才能把它们从屏幕上清除。两个 2 合并成一个 4，两个 4 合并成一个 8，以此类推。每次合并时，游戏都会在棋盘上添加一个新的 2。目标是在整个董事会填满之前达到 2048 年。

## 行动中的计划

当您运行`twentyfortyeight.py`时，输出将如下所示:

```py
Twenty Forty-Eight, by Al Sweigart email@protected
`--snip--`
+-----+-----+-----+-----+
|     |     |     |     |
|     |     |  2  |  16 |
|     |     |     |     |
+-----+-----+-----+-----+
|     |     |     |     |
|     |  16 |  4  |  2  |
|     |     |     |     |
+-----+-----+-----+-----+
|     |     |     |     |
|  2  |     |  4  |  32 |
|     |     |     |     |
+-----+-----+-----+-----+
|     |     |     |     |
|     |     |     |  2  |
|     |     |     |     |
+-----+-----+-----+-----+

Score: 80
Enter move: (WASD or Q to quit)
`--snip--`
```

## 它是如何工作的

这个程序使用“列”数据结构实现它的滑动行为，由四个字符串列表表示:`BLANK`(一个单空格字符串)、`'2'`、`'4'`、`'8'`等等。该列表中的第一个值表示列的底部，而最后一个值表示列的顶部。无论玩家向上、向下、向左或向右滑动牌，组合在一列中的数字总是向下滑动。想象一下重力将瓷砖拉向这些方向。例如，[图 79-1](#calibre_link-353) 显示了一块向右滑动的棋盘。我们将创建四个列表来表示列:

*   `['2', '4', '8', ' ']`
*   `[' ', ' ', ' ', '4']`
*   `[' ', ' ', ' ', '2']`
*   `[' ', ' ', ' ', ' ']`

`combineTilesInColumn()`函数接受一个列列表并返回另一个列列表，匹配的数字被组合并向底部移动。调用`combineTilesInColumn()`的代码负责在适当的方向创建列列表，并用返回的列表更新游戏板。

![f79001](img/75ee4e98ac9c3638ff54c53c1544ec39.png)

:游戏板向右滑动时的列(高亮显示)

```py
"""Twenty Forty-Eight, by Al Sweigart email@protected #  1
A sliding tile game to combine exponentially-increasing numbers. #  2
Inspired by Gabriele Cirulli's 2048, which is a clone of Veewo Studios' #  3
1024, which in turn is a clone of the Threes! game. #  4
More info at https://en.wikipedia.org/wiki/2048_(video_game) #  5
This code is available at https://nostarch.com/big-book-small-python-programming #  6
Tags: large, game, puzzle""" #  7
 #  8
import random, sys #  9
 #  10
# Set up the constants: #  11
BLANK = ''  # A value that represents a blank space on the board. #  12
 #  13
 #  14
def main(): #  15
   print('''Twenty Forty-Eight, by Al Sweigart email@protected #  16
 #  17
Slide all the tiles on the board in one of four directions. Tiles with #  18
like numbers will combine into larger-numbered tiles. A new 2 tile is #  19
added to the board on each move. You win if you can create a 2048 tile. #  20
You lose if the board fills up the tiles before then.''') #  21
   input('Press Enter to begin...') #  22
 #  23
   gameBoard = getNewBoard() #  24
 #  25
   while True:  # Main game loop. #  26
       drawBoard(gameBoard) #  27
       print('Score:', getScore(gameBoard)) #  28
       playerMove = askForPlayerMove() #  29
       gameBoard = makeMove(gameBoard, playerMove) #  30
       addTwoToBoard(gameBoard) #  31
 #  32
       if isFull(gameBoard): #  33
           drawBoard(gameBoard) #  34
           print('Game Over - Thanks for playing!') #  35
           sys.exit() #  36
 #  37
 #  38
def getNewBoard(): #  39
   """Returns a new data structure that represents a board. #  40
 #  41
   It's a dictionary with keys of (x, y) tuples and values of the tile #  42
   at that space. The tile is either a power-of-two integer or BLANK. #  43
   The coordinates are laid out as: #  44
      X0 1 2 3 #  45
     Y+-+-+-+-+ #  46
     0| | | | | #  47
      +-+-+-+-+ #  48
     1| | | | | #  49
      +-+-+-+-+ #  50
     2| | | | | #  51
      +-+-+-+-+ #  52
     3| | | | | #  53
      +-+-+-+-+""" #  54
 #  55
   newBoard = {}  # Contains the board data structure to be returned. #  56
   # Loop over every possible space and set all the tiles to blank: #  57
   for x in range(4): #  58
       for y in range(4): #  59
           newBoard[(x, y)] = BLANK #  60
 #  61
   # Pick two random spaces for the two starting 2's: #  62
   startingTwosPlaced = 0  # The number of starting spaces picked. #  63
   while startingTwosPlaced < 2:  # Repeat for duplicate spaces. #  64
       randomSpace = (random.randint(0, 3), random.randint(0, 3)) #  65
       # Make sure the randomly selected space isn't already taken: #  66
       if newBoard[randomSpace] == BLANK: #  67
           newBoard[randomSpace] = 2 #  68
           startingTwosPlaced = startingTwosPlaced + 1 #  69
 #  70
   return newBoard #  71
 #  72
 #  73
def drawBoard(board): #  74
   """Draws the board data structure on the screen.""" #  75
 #  76
   # Go through each possible space left to right, top to bottom, and #  77
   # create a list of what each space's label should be. #  78
   labels = []  # A list of strings for the number/blank for that tile. #  79
   for y in range(4): #  80
       for x in range(4): #  81
           tile = board[(x, y)]  # Get the tile at this space. #  82
           # Make sure the label is 5 spaces long: #  83
           labelForThisTile = str(tile).center(5) #  84
           labels.append(labelForThisTile) #  85
 #  86
   # The {} are replaced with the label for that tile: #  87
   print(""" #  88
+-----+-----+-----+-----+ #  89
|     |     |     |     | #  90
|{}|{}|{}|{}| #  91
|     |     |     |     | #  92
+-----+-----+-----+-----+ #  93
|     |     |     |     | #  94
|{}|{}|{}|{}| #  95
|     |     |     |     | #  96
+-----+-----+-----+-----+ #  97
|     |     |     |     | #  98
|{}|{}|{}|{}| #  99
|     |     |     |     | # 100
+-----+-----+-----+-----+ # 101
|     |     |     |     | # 102
|{}|{}|{}|{}| # 103
|     |     |     |     | # 104
+-----+-----+-----+-----+ # 105
""".format(*labels)) # 106
 # 107
 # 108
def getScore(board): # 109
    """Returns the sum of all the tiles on the board data structure.""" # 110
    score = 0 # 111
    # Loop over every space and add the tile to the score: # 112
    for x in range(4): # 113
        for y in range(4): # 114
            # Only add non-blank tiles to the score: # 115
            if board[(x, y)] != BLANK: # 116
                score = score + board[(x, y)] # 117
    return score # 118
 # 119
 # 120
def combineTilesInColumn(column): # 121
    """The column is a list of four tile. Index 0 is the "bottom" of # 122
    the column, and tiles are pulled "down" and combine if they are the # 123
    same. For example, combineTilesInColumn([2, BLANK, 2, BLANK]) # 124
    returns [4, BLANK, BLANK, BLANK].""" # 125
 # 126
    # Copy only the numbers (not blanks) from column to combinedTiles # 127
    combinedTiles = []  # A list of the non-blank tiles in column. # 128
    for i in range(4): # 129
        if column[i] != BLANK: # 130
            combinedTiles.append(column[i]) # 131
 # 132
    # Keep adding blanks until there are 4 tiles: # 133
    while len(combinedTiles) < 4: # 134
        combinedTiles.append(BLANK) # 135
 # 136
    # Combine numbers if the one "above" it is the same, and double it. # 137
    for i in range(3):  # Skip index 3: it's the topmost space. # 138
        if combinedTiles[i] == combinedTiles[i + 1]: # 139
            combinedTiles[i] *= 2  # Double the number in the tile. # 140
            # Move the tiles above it down one space: # 141
            for aboveIndex in range(i + 1, 3): # 142
                combinedTiles[aboveIndex] = combinedTiles[aboveIndex + 1] # 143
            combinedTiles[3] = BLANK  # Topmost space is always BLANK. # 144
    return combinedTiles # 145
 # 146
 # 147
def makeMove(board, move): # 148
    """Carries out the move on the board. # 149
 # 150
    The move argument is either 'W', 'A', 'S', or 'D' and the function # 151
    returns the resulting board data structure.""" # 152
 # 153
    # The board is split up into four columns, which are different # 154
    # depending on the direction of the move: # 155
    if move == 'W': # 156
        allColumnsSpaces = [[(0, 0), (0, 1), (0, 2), (0, 3)], # 157
                            [(1, 0), (1, 1), (1, 2), (1, 3)], # 158
                            [(2, 0), (2, 1), (2, 2), (2, 3)], # 159
                            [(3, 0), (3, 1), (3, 2), (3, 3)]] # 160
    elif move == 'A': # 161
        allColumnsSpaces = [[(0, 0), (1, 0), (2, 0), (3, 0)], # 162
                            [(0, 1), (1, 1), (2, 1), (3, 1)], # 163
                            [(0, 2), (1, 2), (2, 2), (3, 2)], # 164
                            [(0, 3), (1, 3), (2, 3), (3, 3)]] # 165
    elif move == 'S': # 166
        allColumnsSpaces = [[(0, 3), (0, 2), (0, 1), (0, 0)], # 167
                            [(1, 3), (1, 2), (1, 1), (1, 0)], # 168
                            [(2, 3), (2, 2), (2, 1), (2, 0)], # 169
                            [(3, 3), (3, 2), (3, 1), (3, 0)]] # 170
    elif move == 'D': # 171
        allColumnsSpaces = [[(3, 0), (2, 0), (1, 0), (0, 0)], # 172
                            [(3, 1), (2, 1), (1, 1), (0, 1)], # 173
                            [(3, 2), (2, 2), (1, 2), (0, 2)], # 174
                            [(3, 3), (2, 3), (1, 3), (0, 3)]] # 175
 # 176
    # The board data structure after making the move: # 177
    boardAfterMove = {} # 178
    for columnSpaces in allColumnsSpaces:  # Loop over all 4 columns. # 179
        # Get the tiles of this column (The first tile is the "bottom" # 180
        # of the column): # 181
        firstTileSpace = columnSpaces[0] # 182
        secondTileSpace = columnSpaces[1] # 183
        thirdTileSpace = columnSpaces[2] # 184
        fourthTileSpace = columnSpaces[3] # 185
 # 186
        firstTile = board[firstTileSpace] # 187
        secondTile = board[secondTileSpace] # 188
        thirdTile = board[thirdTileSpace] # 189
        fourthTile = board[fourthTileSpace] # 190
 # 191
        # Form the column and combine the tiles in it: # 192
        column = [firstTile, secondTile, thirdTile, fourthTile] # 193
        combinedTilesColumn = combineTilesInColumn(column) # 194
 # 195
        # Set up the new board data structure with the combined tiles: # 196
        boardAfterMove[firstTileSpace] = combinedTilesColumn[0] # 197
        boardAfterMove[secondTileSpace] = combinedTilesColumn[1] # 198
        boardAfterMove[thirdTileSpace] = combinedTilesColumn[2] # 199
        boardAfterMove[fourthTileSpace] = combinedTilesColumn[3] # 200
 # 201
    return boardAfterMove # 202
 # 203
 # 204
def askForPlayerMove(): # 205
    """Asks the player for the direction of their next move (or quit). # 206
 # 207
    Ensures they enter a valid move: either 'W', 'A', 'S' or 'D'.""" # 208
    print('Enter move: (WASD or Q to quit)') # 209
    while True:  # Keep looping until they enter a valid move. # 210
        move = input('> ').upper() # 211
        if move == 'Q': # 212
            # End the program: # 213
            print('Thanks for playing!') # 214
            sys.exit() # 215
 # 216
        # Either return the valid move, or loop back and ask again: # 217
        if move in ('W', 'A', 'S', 'D'): # 218
            return move # 219
        else: # 220
            print('Enter one of "W", "A", "S", "D", or "Q".') # 221
 # 222
 # 223
def addTwoToBoard(board): # 224
    """Adds a new 2 tile randomly to the board.""" # 225
    while True: # 226
        randomSpace = (random.randint(0, 3), random.randint(0, 3)) # 227
        if board[randomSpace] == BLANK: # 228
            board[randomSpace] = 2 # 229
            return  # Return after finding one non-blank tile. # 230
 # 231
 # 232
def isFull(board): # 233
    """Returns True if the board data structure has no blanks.""" # 234
    # Loop over every space on the board: # 235
    for x in range(4): # 236
        for y in range(4): # 237
            # If a space is blank, return False: # 238
            if board[(x, y)] == BLANK: # 239
                return False # 240
    return True  # No space is blank, so return True. # 241
 # 242
 # 243
# If this program was run (instead of imported), run the game: # 244
if __name__ == '__main__': # 245
    try: # 246
        main() # 247
    except KeyboardInterrupt: # 248
        sys.exit()  # When Ctrl-C is pressed, end the program.  # 249
```

## 探索计划

试着找出下列问题的答案。尝试对代码进行一些修改，然后重新运行程序，看看这些修改有什么影响。

1.  如果把 118 行的`return score`改成`return 9999`会怎么样？
2.  如果把 229 行的`board[randomSpace] = 2`改成`board[randomSpace] = 256`会怎么样？