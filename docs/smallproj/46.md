# #45 迷宫赛跑者 3D

> 原文：<http://inventwithpython.com/bigbookpython/project45.html>

![](img/9d995d63aaead72cad01120081eb8f75.png)

这款三维迷宫游戏为玩家提供了第一人称视角的迷宫。试着找到你的出路！你可以按照项目 44“迷宫赛跑者 2D”中的说明生成迷宫文件，或者从[`invpy.com/mazes`](https://invpy.com/mazes/)下载迷宫文件。

## 行动中的计划

当您运行 `mazerunner3d.py` 时，输出将如下所示:

```py
Maze Runner 3D, by Al Sweigart email@protected
(Maze files are generated by mazemakerrec.py)
Enter the filename of the maze (or LIST or QUIT):
> maze75x11s1.txt
░░░░░░░░░░░░░░░░░░░
░  \           /  ░
░   \_________/   ░
░    |       |    ░
░    |       |    ░
░    |       |    ░
░    |       |    ░
░    |       |    ░
░    |       |    ░
░    |       |    ░
░    |       |    ░
░    |_______|    ░
░   /         \   ░
░  /           \  ░
░░░░░░░░░░░░░░░░░░░
Location (1, 1)  Direction: NORTH
                   (W)
Enter direction: (A) (D)  or QUIT.
> d
░░░░░░░░░░░░░░░░░░░
░  \              ░
░   \_____________░
░    |            ░
░    |            ░
░    |            ░
░    |            ░
░    |            ░
░    |            ░
░    |            ░
░    |            ░
░    |____________░
░   /             ░
░  /              ░
░░░░░░░░░░░░░░░░░░░
Location (1, 1)  Direction: EAST
`--snip--`
```

## 它是如何工作的

这个 3D 透视 ASCII 艺术从存储在`ALL_OPEN`中的多行字符串开始。该字符串描述了没有路径被墙封闭的位置。然后，程序在`ALL_OPEN`字符串的顶部绘制存储在`CLOSED`字典中的墙，为封闭路径的任何可能组合生成 ASCII 艺术。例如，下面是程序如何生成视图，其中墙在玩家的左边:

```py
 \               \
____         ____            \_              \_        ____
   |\       /|                |               |       /|
   ||       ||                |               |       ||
   ||__   __||                |               |__   __||
   || |\ /| ||                |               | |\ /| ||
   || | X | ||        +       |       =       | | X | ||
   || |/ \| ||                |               | |/ \| ||
   ||_/   \_||                |               |_/   \_||
   ||       ||                |               |       ||
___|/       \|___             |               |       \|___
                             /               /
                            /               /
```

在显示字符串之前，源代码中 ASCII 字符中的句点会被删除；它们的存在只是为了使输入代码更容易，所以你不要插入或遗漏空格。

这是 3D 迷宫的源代码:

```py
"""Maze 3D, by Al Sweigart email@protected #  1
Move around a maze and try to escape... in 3D! #  2
This code is available at https://nostarch.com/big-book-small-python-programming #  3
Tags: extra-large, artistic, maze, game""" #  4
 #  5
import copy, sys, os #  6
 #  7
# Set up the constants: #  8
WALL = '#' #  9
EMPTY = ' ' #  10
START = 'S' #  11
EXIT = 'E' #  12
BLOCK = chr(9617)  # Character 9617 is '░' #  13
NORTH = 'NORTH' #  14
SOUTH = 'SOUTH' #  15
EAST = 'EAST' #  16
WEST = 'WEST' #  17
 #  18
 #  19
def wallStrToWallDict(wallStr): #  20
   """Takes a string representation of a wall drawing (like those in #  21
   ALL_OPEN or CLOSED) and returns a representation in a dictionary #  22
   with (x, y) tuples as keys and single-character strings of the #  23
   character to draw at that x, y location.""" #  24
   wallDict = {} #  25
   height = 0 #  26
   width = 0 #  27
   for y, line in enumerate(wallStr.splitlines()): #  28
       if y > height: #  29
           height = y #  30
       for x, character in enumerate(line): #  31
           if x > width: #  32
               width = x #  33
           wallDict[(x, y)] = character #  34
   wallDict['height'] = height + 1 #  35
   wallDict['width'] = width + 1 #  36
   return wallDict #  37
 #  38
EXIT_DICT = {(0, 0): 'E', (1, 0): 'X', (2, 0): 'I', #  39
            (3, 0): 'T', 'height': 1, 'width': 4} #  40
 #  41
# The way we create the strings to display is by converting the pictures #  42
# in these multiline strings to dictionaries using wallStrToWallDict(). #  43
# Then we compose the wall for the player's location and direction by #  44
# "pasting" the wall dictionaries in CLOSED on top of the wall dictionary #  45
# in ALL_OPEN. #  46
 #  47
ALL_OPEN = wallStrToWallDict(r''' #  48
................. #  49
____.........____ #  50
...|\......./|... #  51
...||.......||... #  52
...||__...__||... #  53
...||.|\./|.||... #  54
...||.|.X.|.||... #  55
...||.|/.\|.||... #  56
...||_/...\_||... #  57
...||.......||... #  58
___|/.......\|___ #  59
................. #  60
.................'''.strip()) #  61
# The strip() call is used to remove the newline #  62
# at the start of this multiline string. #  63
 #  64
CLOSED = {} #  65
CLOSED['A'] = wallStrToWallDict(r''' #  66
_____ #  67
..... #  68
..... #  69
..... #  70
_____'''.strip()) # Paste to 6, 4. #  71
 #  72
CLOSED['B'] = wallStrToWallDict(r''' #  73
.\. #  74
..\ #  75
... #  76
... #  77
... #  78
../ #  79
./.'''.strip()) # Paste to 4, 3. #  80
 #  81
CLOSED['C'] = wallStrToWallDict(r''' #  82
___________ #  83
........... #  84
........... #  85
........... #  86
........... #  87
........... #  88
........... #  89
........... #  90
........... #  91
___________'''.strip()) # Paste to 3, 1. #  92
 #  93
CLOSED['D'] = wallStrToWallDict(r''' #  94
./. #  95
/.. #  96
... #  97
... #  98
... #  99
\.. # 100
.\.'''.strip()) # Paste to 10, 3. # 101
 # 102
CLOSED['E'] = wallStrToWallDict(r''' # 103
..\.. # 104
...\_ # 105
....| # 106
....| # 107
....| # 108
....| # 109
....| # 110
....| # 111
....| # 112
....| # 113
....| # 114
.../. # 115
../..'''.strip()) # Paste to 0, 0. # 116
 # 117
CLOSED['F'] = wallStrToWallDict(r''' # 118
../.. # 119
_/... # 120
|.... # 121
|.... # 122
|.... # 123
|.... # 124
|.... # 125
|.... # 126
|.... # 127
|.... # 128
|.... # 129
.\... # 130
..\..'''.strip()) # Paste to 12, 0. # 131
 # 132
def displayWallDict(wallDict): # 133
    """Display a wall dictionary, as returned by wallStrToWallDict(), on # 134
    the screen.""" # 135
    print(BLOCK * (wallDict['width'] + 2)) # 136
    for y in range(wallDict['height']): # 137
        print(BLOCK, end='') # 138
        for x in range(wallDict['width']): # 139
            wall = wallDict[(x, y)] # 140
            if wall == '.': # 141
                wall = ' ' # 142
            print(wall, end='') # 143
        print(BLOCK)  # Print block with a newline. # 144
    print(BLOCK * (wallDict['width'] + 2)) # 145
 # 146
 # 147
def pasteWallDict(srcWallDict, dstWallDict, left, top): # 148
    """Copy the wall representation dictionary in srcWallDict on top of # 149
    the one in dstWallDict, offset to the position given by left, top.""" # 150
    dstWallDict = copy.copy(dstWallDict) # 151
    for x in range(srcWallDict['width']): # 152
        for y in range(srcWallDict['height']): # 153
            dstWallDict[(x + left, y + top)] = srcWallDict[(x, y)] # 154
    return dstWallDict # 155
 # 156
 # 157
def makeWallDict(maze, playerx, playery, playerDirection, exitx, exity): # 158
    """From the player's position and direction in the maze (which has # 159
    an exit at exitx, exity), create the wall representation dictionary # 160
    by pasting wall dictionaries on top of ALL_OPEN, then return it.""" # 161
 # 162
    # The A-F "sections" (which are relative to the player's direction) # 163
    # determine which walls in the maze we check to see if we need to # 164
    # paste them over the wall representation dictionary we're creating. # 165
 # 166
    if playerDirection == NORTH: # 167
        # Map of the sections, relative  A # 168
        # to the player @:              BCD (Player facing north) # 169
        #                               email@protected # 170
        offsets = (('A', 0, -2), ('B', -1, -1), ('C', 0, -1), # 171
                   ('D', 1, -1), ('E', -1, 0), ('F', 1, 0)) # 172
    if playerDirection == SOUTH: # 173
        # Map of the sections, relative email@protected # 174
        # to the player @:              DCB (Player facing south) # 175
        #                                A # 176
        offsets = (('A', 0, 2), ('B', 1, 1), ('C', 0, 1), # 177
                   ('D', -1, 1), ('E', 1, 0), ('F', -1, 0)) # 178
    if playerDirection == EAST: # 179
        # Map of the sections, relative EB # 180
        # to the player @:              @CA (Player facing east) # 181
        #                               FD # 182
        offsets = (('A', 2, 0), ('B', 1, -1), ('C', 1, 0), # 183
                   ('D', 1, 1), ('E', 0, -1), ('F', 0, 1)) # 184
    if playerDirection == WEST: # 185
        # Map of the sections, relative  DF # 186
        # to the player @:              email@protected (Player facing west) # 187
        #                                BE # 188
        offsets = (('A', -2, 0), ('B', -1, 1), ('C', -1, 0), # 189
                   ('D', -1, -1), ('E', 0, 1), ('F', 0, -1)) # 190
 # 191
    section = {} # 192
    for sec, xOff, yOff in offsets: # 193
        section[sec] = maze.get((playerx + xOff, playery + yOff), WALL) # 194
        if (playerx + xOff, playery + yOff) == (exitx, exity): # 195
            section[sec] = EXIT # 196
 # 197
    wallDict = copy.copy(ALL_OPEN) # 198
    PASTE_CLOSED_TO = {'A': (6, 4), 'B': (4, 3), 'C': (3, 1), # 199
                       'D': (10, 3), 'E': (0, 0), 'F': (12, 0)} # 200
    for sec in 'ABDCEF': # 201
        if section[sec] == WALL: # 202
            wallDict = pasteWallDict(CLOSED[sec], wallDict, # 203
                PASTE_CLOSED_TO[sec][0], PASTE_CLOSED_TO[sec][1]) # 204
 # 205
    # Draw the EXIT sign if needed: # 206
    if section['C'] == EXIT: # 207
        wallDict = pasteWallDict(EXIT_DICT, wallDict, 7, 9) # 208
    if section['E'] == EXIT: # 209
        wallDict = pasteWallDict(EXIT_DICT, wallDict, 0, 11) # 210
    if section['F'] == EXIT: # 211
        wallDict = pasteWallDict(EXIT_DICT, wallDict, 13, 11) # 212
 # 213
    return wallDict # 214
 # 215
 # 216
print('Maze Runner 3D, by Al Sweigart email@protected') # 217
print('(Maze files are generated by mazemakerrec.py)') # 218
 # 219
# Get the maze file's filename from the user: # 220
while True: # 221
    print('Enter the filename of the maze (or LIST or QUIT):') # 222
    filename = input('> ') # 223
 # 224
    # List all the maze files in the current folder: # 225
    if filename.upper() == 'LIST': # 226
        print('Maze files found in', os.getcwd()) # 227
        for fileInCurrentFolder in os.listdir(): # 228
            if (fileInCurrentFolder.startswith('maze') # 229
            and fileInCurrentFolder.endswith('.txt')): # 230
                print('  ', fileInCurrentFolder) # 231
        continue # 232
 # 233
    if filename.upper() == 'QUIT': # 234
        sys.exit() # 235
 # 236
    if os.path.exists(filename): # 237
        break # 238
    print('There is no file named', filename) # 239
 # 240
# Load the maze from a file: # 241
mazeFile = open(filename) # 242
maze = {} # 243
lines = mazeFile.readlines() # 244
px = None # 245
py = None # 246
exitx = None # 247
exity = None # 248
y = 0 # 249
for line in lines: # 250
    WIDTH = len(line.rstrip()) # 251
    for x, character in enumerate(line.rstrip()): # 252
        assert character in (WALL, EMPTY, START, EXIT), 'Invalid character at column {}, line {}'.format(x + 1, y + 1) # 253
        if character in (WALL, EMPTY): # 254
            maze[(x, y)] = character # 255
        elif character == START: # 256
            px, py = x, y # 257
            maze[(x, y)] = EMPTY # 258
        elif character == EXIT: # 259
            exitx, exity = x, y # 260
            maze[(x, y)] = EMPTY # 261
    y += 1 # 262
HEIGHT = y # 263
 # 264
assert px != None and py != None, 'No start point in file.' # 265
assert exitx != None and exity != None, 'No exit point in file.' # 266
pDir = NORTH # 267
 # 268
 # 269
while True:  # Main game loop. # 270
    displayWallDict(makeWallDict(maze, px, py, pDir, exitx, exity)) # 271
 # 272
    while True: # Get user move. # 273
        print('Location ({}, {})  Direction: {}'.format(px, py, pDir)) # 274
        print('                   (W)') # 275
        print('Enter direction: (A) (D)  or QUIT.') # 276
        move = input('> ').upper() # 277
 # 278
        if move == 'QUIT': # 279
            print('Thanks for playing!') # 280
            sys.exit() # 281
 # 282
        if (move not in ['F', 'L', 'R', 'W', 'A', 'D'] # 283
            and not move.startswith('T')): # 284
            print('Please enter one of F, L, or R (or W, A, D).') # 285
            continue # 286
 # 287
        # Move the player according to their intended move: # 288
        if move == 'F' or move == 'W': # 289
            if pDir == NORTH and maze[(px, py - 1)] == EMPTY: # 290
                py -= 1 # 291
                break # 292
            if pDir == SOUTH and maze[(px, py + 1)] == EMPTY: # 293
                py += 1 # 294
                break # 295
            if pDir == EAST and maze[(px + 1, py)] == EMPTY: # 296
                px += 1 # 297
                break # 298
            if pDir == WEST and maze[(px - 1, py)] == EMPTY: # 299
                px -= 1 # 300
                break # 301
        elif move == 'L' or move == 'A': # 302
            pDir = {NORTH: WEST, WEST: SOUTH, # 303
                    SOUTH: EAST, EAST: NORTH}[pDir] # 304
            break # 305
        elif move == 'R' or move == 'D': # 306
            pDir = {NORTH: EAST, EAST: SOUTH, # 307
                    SOUTH: WEST, WEST: NORTH}[pDir] # 308
            break # 309
        elif move.startswith('T'):  # Cheat code: 'T x,y' # 310
            px, py = move.split()[1].split(',') # 311
            px = int(px) # 312
            py = int(py) # 313
            break # 314
        else: # 315
            print('You cannot move in that direction.') # 316
 # 317
    if (px, py) == (exitx, exity): # 318
        print('You have reached the exit! Good job!') # 319
        print('Thanks for playing!') # 320
        sys.exit()  # 321
```

## 探索计划

试着找出下列问题的答案。尝试对代码进行一些修改，然后重新运行程序，看看这些修改有什么影响。

1.  如果把 279 行的`move == 'QUIT'`改成`move == 'quit'`会导致什么 bug？
2.  怎样才能解除心灵运输的欺骗？