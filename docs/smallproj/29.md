# 28 号洪水

> 原文：<http://inventwithpython.com/bigbookpython/project28.html>

![](img/9d995d63aaead72cad01120081eb8f75.png)

Flooder 是一款色彩丰富的游戏，玩家试图通过改变左上角瓷砖的颜色来用单一颜色填充棋盘。这种新颜色会扩展到所有与原始颜色匹配的相邻图块。类似于洪水 It 手游。这个程序也有一个色盲模式，它使用形状而不是扁平的彩色瓷砖。它依靠递归洪水填充算法来绘制电路板，其工作方式类似于许多绘画应用程序中的“油漆桶”或“填充”工具。

## 行动中的计划

图 28-1 显示了运行 `flooder.py` 时的输出。

![f28001](img/05745f084cde57121b979ccabc4e0415.png)

:色盲模式下投光灯游戏的输出，显示不同的形状而不是矩形

## 它是如何工作的

可访问性是视频游戏中的一个大问题，解决这个问题可以采取多种形式。例如，deuteranopia，或红绿色盲，会导致红色和绿色的阴影看起来相同，从而很难区分屏幕上的红色物体和绿色物体。我们可以通过使用不同的形状而不是不同的颜色来使 Flooder 更容易使用。请注意，即使是色盲模式仍然使用颜色。这意味着如果你愿意，你可以取消“标准”模式，甚至让色盲用户也可以在色盲模式下玩游戏。最好的易访问性设计是那些从一开始就包含易访问性考虑的设计，而不是将它们作为一个单独的模式添加进去。这减少了我们必须编写的代码量，并使未来的错误修复变得更加容易。

其他可访问性问题包括确保文本足够大，即使没有完美的视觉也可以阅读，声音效果有视觉提示，口语有针对听力障碍者的字幕，以及控件可以重新映射到其他键盘按键，以便人们可以用一只手玩游戏。YouTube 频道游戏制作工具包有一个名为“为残疾人设计”的视频系列，涵盖了在设计游戏时考虑无障碍的许多方面。

```py
"""Flooder, by Al Sweigart email@protected #  1
A colorful game where you try to fill the board with a single color. Has #  2
a mode for colorblind players. #  3
Inspired by the "Flood It!" game. #  4
This code is available at https://nostarch.com/big-book-small-python-programming #  5
Tags: large, bext, game""" #  6
 #  7
import random, sys #  8
 #  9
try: #  10
   import bext #  11
except ImportError: #  12
   print('This program requires the bext module, which you') #  13
   print('can install by following the instructions at') #  14
   print('https://pypi.org/project/Bext/') #  15
   sys.exit() #  16
 #  17
# Set up the constants: #  18
BOARD_WIDTH = 16  # (!) Try changing this to 4 or 40. #  19
BOARD_HEIGHT = 14  # (!) Try changing this to 4 or 20. #  20
MOVES_PER_GAME = 20  # (!) Try changing this to 3 or 300. #  21
 #  22
# Constants for the different shapes used in colorblind mode: #  23
HEART     = chr(9829)  # Character 9829 is '♥'. #  24
DIAMOND   = chr(9830)  # Character 9830 is '♦'. #  25
SPADE     = chr(9824)  # Character 9824 is '♠'. #  26
CLUB      = chr(9827)  # Character 9827 is '♣'. #  27
BALL      = chr(9679)  # Character 9679 is '●'. #  28
TRIANGLE  = chr(9650)  # Character 9650 is '▲'. #  29
 #  30
BLOCK     = chr(9608)  # Character 9608 is '█' #  31
LEFTRIGHT = chr(9472)  # Character 9472 is '─' #  32
UPDOWN    = chr(9474)  # Character 9474 is '│' #  33
DOWNRIGHT = chr(9484)  # Character 9484 is '┌' #  34
DOWNLEFT  = chr(9488)  # Character 9488 is '┐' #  35
UPRIGHT   = chr(9492)  # Character 9492 is '└' #  36
UPLEFT    = chr(9496)  # Character 9496 is '┘' #  37
# A list of chr() codes is at https://inventwithpython.com/chr #  38
 #  39
# All the color/shape tiles used on the board: #  40
TILE_TYPES = (0, 1, 2, 3, 4, 5) #  41
COLORS_MAP = {0: 'red', 1: 'green', 2:'blue', #  42
             3:'yellow', 4:'cyan', 5:'purple'} #  43
COLOR_MODE = 'color mode' #  44
SHAPES_MAP = {0: HEART, 1: TRIANGLE, 2: DIAMOND, #  45
             3: BALL, 4: CLUB, 5: SPADE} #  46
SHAPE_MODE = 'shape mode' #  47
 #  48
 #  49
def main(): #  50
   bext.bg('black') #  51
   bext.fg('white') #  52
   bext.clear() #  53
   print('''Flooder, by Al Sweigart email@protected #  54
 #  55
Set the upper left color/shape, which fills in all the #  56
adjacent squares of that color/shape. Try to make the #  57
entire board the same color/shape.''') #  58
 #  59
   print('Do you want to play in colorblind mode? Y/N') #  60
   response = input('> ') #  61
   if response.upper().startswith('Y'): #  62
       displayMode = SHAPE_MODE #  63
   else: #  64
       displayMode = COLOR_MODE #  65
 #  66
   gameBoard = getNewBoard() #  67
   movesLeft = MOVES_PER_GAME #  68
 #  69
   while True:  # Main game loop. #  70
       displayBoard(gameBoard, displayMode) #  71
 #  72
       print('Moves left:', movesLeft) #  73
       playerMove = askForPlayerMove(displayMode) #  74
       changeTile(playerMove, gameBoard, 0, 0) #  75
       movesLeft -= 1 #  76
 #  77
       if hasWon(gameBoard): #  78
           displayBoard(gameBoard, displayMode) #  79
           print('You have won!') #  80
           break #  81
       elif movesLeft == 0: #  82
           displayBoard(gameBoard, displayMode) #  83
           print('You have run out of moves!') #  84
           break #  85
 #  86
 #  87
def getNewBoard(): #  88
   """Return a dictionary of a new Flood It board.""" #  89
 #  90
   # Keys are (x, y) tuples, values are the tile at that position. #  91
   board = {} #  92
 #  93
   # Create random colors for the board. #  94
   for x in range(BOARD_WIDTH): #  95
       for y in range(BOARD_HEIGHT): #  96
           board[(x, y)] = random.choice(TILE_TYPES) #  97
 #  98
   # Make several tiles the same as their neighbor. This creates groups #  99
    # of the same color/shape. # 100
    for i in range(BOARD_WIDTH * BOARD_HEIGHT): # 101
        x = random.randint(0, BOARD_WIDTH - 2) # 102
        y = random.randint(0, BOARD_HEIGHT - 1) # 103
        board[(x + 1, y)] = board[(x, y)] # 104
    return board # 105
 # 106
 # 107
def displayBoard(board, displayMode): # 108
    """Display the board on the screen.""" # 109
    bext.fg('white') # 110
    # Display the top edge of the board: # 111
    print(DOWNRIGHT + (LEFTRIGHT * BOARD_WIDTH) + DOWNLEFT) # 112
 # 113
    # Display each row: # 114
    for y in range(BOARD_HEIGHT): # 115
        bext.fg('white') # 116
        if y == 0:  # The first row begins with '>'. # 117
            print('>', end='') # 118
        else:  # Later rows begin with a white vertical line. # 119
            print(UPDOWN, end='') # 120
 # 121
        # Display each tile in this row: # 122
        for x in range(BOARD_WIDTH): # 123
            bext.fg(COLORS_MAP[board[(x, y)]]) # 124
            if displayMode == COLOR_MODE: # 125
                print(BLOCK, end='') # 126
            elif displayMode == SHAPE_MODE: # 127
                print(SHAPES_MAP[board[(x, y)]], end='') # 128
 # 129
        bext.fg('white') # 130
        print(UPDOWN)  # Rows end with a white vertical line. # 131
    # Display the bottom edge of the board: # 132
    print(UPRIGHT + (LEFTRIGHT * BOARD_WIDTH) + UPLEFT) # 133
 # 134
 # 135
def askForPlayerMove(displayMode): # 136
    """Let the player select a color to paint the upper left tile.""" # 137
    while True: # 138
        bext.fg('white') # 139
        print('Choose one of ', end='') # 140
 # 141
        if displayMode == COLOR_MODE: # 142
            bext.fg('red') # 143
            print('(R)ed ', end='') # 144
            bext.fg('green') # 145
            print('(G)reen ', end='') # 146
            bext.fg('blue') # 147
            print('(B)lue ', end='') # 148
            bext.fg('yellow') # 149
            print('(Y)ellow ', end='') # 150
            bext.fg('cyan') # 151
            print('(C)yan ', end='') # 152
            bext.fg('purple') # 153
            print('(P)urple ', end='') # 154
        elif displayMode == SHAPE_MODE: # 155
            bext.fg('red') # 156
            print('(H)eart, ', end='') # 157
            bext.fg('green') # 158
            print('(T)riangle, ', end='') # 159
            bext.fg('blue') # 160
            print('(D)iamond, ', end='') # 161
            bext.fg('yellow') # 162
            print('(B)all, ', end='') # 163
            bext.fg('cyan') # 164
            print('(C)lub, ', end='') # 165
            bext.fg('purple') # 166
            print('(S)pade, ', end='') # 167
        bext.fg('white') # 168
        print('or QUIT:') # 169
        response = input('> ').upper() # 170
        if response == 'QUIT': # 171
            print('Thanks for playing!') # 172
            sys.exit() # 173
        if displayMode == COLOR_MODE and response in tuple('RGBYCP'): # 174
            # Return a tile type number based on the response: # 175
            return {'R': 0, 'G': 1, 'B': 2, # 176
                'Y': 3, 'C': 4, 'P': 5}[response] # 177
        if displayMode == SHAPE_MODE and response in tuple('HTDBCS'): # 178
            # Return a tile type number based on the response: # 179
            return {'H': 0, 'T': 1, 'D':2, # 180
                'B': 3, 'C': 4, 'S': 5}[response] # 181
 # 182
 # 183
def changeTile(tileType, board, x, y, charToChange=None): # 184
    """Change the color/shape of a tile using the recursive flood fill # 185
    algorithm.""" # 186
    if x == 0 and y == 0: # 187
        charToChange = board[(x, y)] # 188
        if tileType == charToChange: # 189
            return  # Base Case: Already is the same tile. # 190
 # 191
    board[(x, y)] = tileType # 192
 # 193
    if x > 0 and board[(x - 1, y)] == charToChange: # 194
        # Recursive Case: Change the left neighbor's tile: # 195
        changeTile(tileType, board, x - 1, y, charToChange) # 196
    if y > 0 and board[(x, y - 1)] == charToChange: # 197
        # Recursive Case: Change the top neighbor's tile: # 198
        changeTile(tileType, board, x, y - 1, charToChange) # 199
    if x < BOARD_WIDTH - 1 and board[(x + 1, y)] == charToChange: # 200
        # Recursive Case: Change the right neighbor's tile: # 201
        changeTile(tileType, board, x + 1, y, charToChange) # 202
    if y < BOARD_HEIGHT - 1 and board[(x, y + 1)] == charToChange: # 203
        # Recursive Case: Change the bottom neighbor's tile: # 204
        changeTile(tileType, board, x, y + 1, charToChange) # 205
 # 206
 # 207
def hasWon(board): # 208
    """Return True if the entire board is one color/shape.""" # 209
    tile = board[(0, 0)] # 210
 # 211
    for x in range(BOARD_WIDTH): # 212
        for y in range(BOARD_HEIGHT): # 213
            if board[(x, y)] != tile: # 214
                return False # 215
    return True # 216
 # 217
 # 218
# If this program was run (instead of imported), run the game: # 219
if __name__ == '__main__': # 220
    main()  # 221
```

在输入源代码并运行几次之后，尝试对其进行实验性的修改。标有`(!)`的评论对你可以做的小改变有建议。你也可以自己想办法做到以下几点:

*   添加其他形状和颜色。
*   创建除矩形之外的其他纸板形状。

## 探索计划

试着找出下列问题的答案。尝试对代码进行一些修改，然后重新运行程序，看看这些修改有什么影响。

1.  如果将第 92 行的`board = {}`改为`board = []`，会得到什么错误信息？
2.  如果将第 105 行的`return board`改为`return None`，会得到什么错误信息？
3.  如果把第 76 行的`movesLeft -= 1`改成`movesLeft -= 0`会怎么样？