# #37 饥饿机器人

> 原文：<http://inventwithpython.com/bigbookpython/project37.html>

![](img/9d995d63aaead72cad01120081eb8f75.png)

你和饥饿的机器人被困在一个迷宫里！你不知道机器人为什么需要吃饭，但你也不想知道。机器人的程序设计很糟糕，即使被墙挡住，它们也会直接向你移动。你必须欺骗机器人互相碰撞(或死亡的机器人)而不被抓住。

你有一个个人传送装置，可以把你送到一个随机的新地方，但它的电池只够两次旅行。此外，你和机器人可以溜过角落！

## 行动中的计划

当您运行 `hungryrobots.py` 时，输出将如下所示:

```py
Hungry Robots, by Al Sweigart email@protected
`--snip--`
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
░   ░ R             R ░  ░             ░
░ ░    ░░░   R░                    ░░  ░
░     ░ ░    ░ ░  ░         ░  ░░░     ░
░    R░   ░    ░      ░░   ░░     ░    ░
░ ░░  ░     ░ ░░░    ░           ░     ░
░ ░░    ░   RX░░░  ░  ░  ░      ░      ░
░          ░ R     R        R ░      ░ ░
░    ░   ░            ░        ░   R ░ ░
░ ░ R       R     ░   R ░   R          ░
░   ░  ░     ░       ░  ░       ░   ░  ░
░  @            ░          ░    R░░░ ░ ░
░   ░  ░░      ░░                 ░    ░
░  ░   ░░  ░            ░     R       ░░
░░X          ░  ░        ░ R ░░RR  ░ R ░
░RR R       R ░    ░          ░       R░
░   ░░  RRR   R                        ░
░           ░░R     ░                  ░
░      R  ░ ░                     ░    ░
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
(T)eleports remaining: 2
                    (Q) (W) ( )
                    (A) (S) (D)
Enter move or QUIT: (Z) (X) ( )
`--snip--`
```

## 它是如何工作的

在这个游戏中代表位置的 x 和 y 笛卡尔坐标允许我们使用数学来确定机器人应该移动的方向。在编程中，x 坐标向右增加，y 坐标向下增加。这意味着如果机器人的 x 坐标大于玩家的坐标，它应该向左移动(即代码应该从其当前的 x 坐标中减去)以靠近玩家。如果机器人的 x 坐标更小，它应该向右移动(也就是说，代码应该添加到其当前的 x 坐标中)。这同样适用于基于相对 y 坐标的上下移动。

```py
"""Hungry Robots, by Al Sweigart email@protected #  1
Escape the hungry robots by making them crash into each other. #  2
This code is available at https://nostarch.com/big-book-small-python-programming #  3
Tags: large, game""" #  4
 #  5
import random, sys #  6
 #  7
# Set up the constants: #  8
WIDTH = 40           # (!) Try changing this to 70 or 10. #  9
HEIGHT = 20          # (!) Try changing this to 10. #  10
NUM_ROBOTS = 10      # (!) Try changing this to 1 or 30. #  11
NUM_TELEPORTS = 2    # (!) Try changing this to 0 or 9999. #  12
NUM_DEAD_ROBOTS = 2  # (!) Try changing this to 0 or 20. #  13
NUM_WALLS = 100      # (!) Try changing this to 0 or 300. #  14
 #  15
EMPTY_SPACE = ' '    # (!) Try changing this to '.'. #  16
PLAYER = '@'         # (!) Try changing this to 'R'. #  17
ROBOT = 'R'          # (!) Try changing this to '@'. #  18
DEAD_ROBOT = 'X'     # (!) Try changing this to 'R'. #  19
 #  20
# (!) Try changing this to '#' or 'O' or ' ': #  21
WALL = chr(9617)  # Character 9617 is '░' #  22
 #  23
 #  24
def main(): #  25
   print('''Hungry Robots, by Al Sweigart email@protected #  26
 #  27
You are trapped in a maze with hungry robots! You don't know why robots #  28
need to eat, but you don't want to find out. The robots are badly #  29
programmed and will move directly toward you, even if blocked by walls. #  30
You must trick the robots into crashing into each other (or dead robots) #  31
without being caught. You have a personal teleporter device, but it only #  32
has enough battery for {} trips. Keep in mind, you and robots can slip #  33
through the corners of two diagonal walls! #  34
'''.format(NUM_TELEPORTS)) #  35
 #  36
   input('Press Enter to begin...') #  37
 #  38
   # Set up a new game: #  39
   board = getNewBoard() #  40
   robots = addRobots(board) #  41
   playerPosition = getRandomEmptySpace(board, robots) #  42
   while True:  # Main game loop. #  43
       displayBoard(board, robots, playerPosition) #  44
 #  45
       if len(robots) == 0:  # Check if the player has won. #  46
           print('All the robots have crashed into each other and you') #  47
           print('lived to tell the tale! Good job!') #  48
           sys.exit() #  49
 #  50
       # Move the player and robots: #  51
       playerPosition = askForPlayerMove(board, robots, playerPosition) #  52
       robots = moveRobots(board, robots, playerPosition) #  53
 #  54
       for x, y in robots:  # Check if the player has lost. #  55
           if (x, y) == playerPosition: #  56
               displayBoard(board, robots, playerPosition) #  57
               print('You have been caught by a robot!') #  58
               sys.exit() #  59
 #  60
 #  61
def getNewBoard(): #  62
   """Returns a dictionary that represents the board. The keys are #  63
   (x, y) tuples of integer indexes for board positions, the values are #  64
   WALL, EMPTY_SPACE, or DEAD_ROBOT. The dictionary also has the key #  65
   'teleports' for the number of teleports the player has left. #  66
   The living robots are stored separately from the board dictionary.""" #  67
   board = {'teleports': NUM_TELEPORTS} #  68
 #  69
   # Create an empty board: #  70
   for x in range(WIDTH): #  71
       for y in range(HEIGHT): #  72
           board[(x, y)] = EMPTY_SPACE #  73
 #  74
   # Add walls on the edges of the board: #  75
   for x in range(WIDTH): #  76
       board[(x, 0)] = WALL  # Make top wall. #  77
       board[(x, HEIGHT - 1)] = WALL  # Make bottom wall. #  78
   for y in range(HEIGHT): #  79
       board[(0, y)] = WALL  # Make left wall. #  80
       board[(WIDTH - 1, y)] = WALL  # Make right wall. #  81
 #  82
   # Add the random walls: #  83
   for i in range(NUM_WALLS): #  84
       x, y = getRandomEmptySpace(board, []) #  85
       board[(x, y)] = WALL #  86
 #  87
   # Add the starting dead robots: #  88
   for i in range(NUM_DEAD_ROBOTS): #  89
       x, y = getRandomEmptySpace(board, []) #  90
       board[(x, y)] = DEAD_ROBOT #  91
   return board #  92
 #  93
 #  94
def getRandomEmptySpace(board, robots): #  95
   """Return a (x, y) integer tuple of an empty space on the board.""" #  96
   while True: #  97
       randomX = random.randint(1, WIDTH - 2) #  98
       randomY = random.randint(1, HEIGHT - 2) #  99
        if isEmpty(randomX, randomY, board, robots): # 100
            break # 101
    return (randomX, randomY) # 102
 # 103
 # 104
def isEmpty(x, y, board, robots): # 105
    """Return True if the (x, y) is empty on the board and there's also # 106
    no robot there.""" # 107
    return board[(x, y)] == EMPTY_SPACE and (x, y) not in robots # 108
 # 109
 # 110
def addRobots(board): # 111
    """Add NUM_ROBOTS number of robots to empty spaces on the board and # 112
    return a list of these (x, y) spaces where robots are now located.""" # 113
    robots = [] # 114
    for i in range(NUM_ROBOTS): # 115
        x, y = getRandomEmptySpace(board, robots) # 116
        robots.append((x, y)) # 117
    return robots # 118
 # 119
 # 120
def displayBoard(board, robots, playerPosition): # 121
    """Display the board, robots, and player on the screen.""" # 122
    # Loop over every space on the board: # 123
    for y in range(HEIGHT): # 124
        for x in range(WIDTH): # 125
            # Draw the appropriate character: # 126
            if board[(x, y)] == WALL: # 127
                print(WALL, end='') # 128
            elif board[(x, y)] == DEAD_ROBOT: # 129
                print(DEAD_ROBOT, end='') # 130
            elif (x, y) == playerPosition: # 131
                print(PLAYER, end='') # 132
            elif (x, y) in robots: # 133
                print(ROBOT, end='') # 134
            else: # 135
                print(EMPTY_SPACE, end='') # 136
        print()  # Print a newline. # 137
 # 138
 # 139
def askForPlayerMove(board, robots, playerPosition): # 140
    """Returns the (x, y) integer tuple of the place the player moves # 141
    next, given their current location and the walls of the board.""" # 142
    playerX, playerY = playerPosition # 143
 # 144
    # Find which directions aren't blocked by a wall: # 145
    q = 'Q' if isEmpty(playerX - 1, playerY - 1, board, robots) else ' ' # 146
    w = 'W' if isEmpty(playerX + 0, playerY - 1, board, robots) else ' ' # 147
    e = 'E' if isEmpty(playerX + 1, playerY - 1, board, robots) else ' ' # 148
    d = 'D' if isEmpty(playerX + 1, playerY + 0, board, robots) else ' ' # 149
    c = 'C' if isEmpty(playerX + 1, playerY + 1, board, robots) else ' ' # 150
    x = 'X' if isEmpty(playerX + 0, playerY + 1, board, robots) else ' ' # 151
    z = 'Z' if isEmpty(playerX - 1, playerY + 1, board, robots) else ' ' # 152
    a = 'A' if isEmpty(playerX - 1, playerY + 0, board, robots) else ' ' # 153
    allMoves = (q + w + e + d + c + x + a + z + 'S') # 154
 # 155
    while True: # 156
        # Get player's move: # 157
        print('(T)eleports remaining: {}'.format(board["teleports"])) # 158
        print('                    ({}) ({}) ({})'.format(q, w, e)) # 159
        print('                    ({}) (S) ({})'.format(a, d)) # 160
        print('Enter move or QUIT: ({}) ({}) ({})'.format(z, x, c)) # 161
 # 162
        move = input('> ').upper() # 163
        if move == 'QUIT': # 164
            print('Thanks for playing!') # 165
            sys.exit() # 166
        elif move == 'T' and board['teleports'] > 0: # 167
            # Teleport the player to a random empty space: # 168
            board['teleports'] -= 1 # 169
            return getRandomEmptySpace(board, robots) # 170
        elif move != '' and move in allMoves: # 171
            # Return the new player position based on their move: # 172
            return {'Q': (playerX - 1, playerY - 1), # 173
                    'W': (playerX + 0, playerY - 1), # 174
                    'E': (playerX + 1, playerY - 1), # 175
                    'D': (playerX + 1, playerY + 0), # 176
                    'C': (playerX + 1, playerY + 1), # 177
                    'X': (playerX + 0, playerY + 1), # 178
                    'Z': (playerX - 1, playerY + 1), # 179
                    'A': (playerX - 1, playerY + 0), # 180
                    'S': (playerX, playerY)}[move] # 181
 # 182
 # 183
def moveRobots(board, robotPositions, playerPosition): # 184
    """Return a list of (x, y) tuples of new robot positions after they # 185
    have tried to move toward the player.""" # 186
    playerx, playery = playerPosition # 187
    nextRobotPositions = [] # 188
 # 189
    while len(robotPositions) > 0: # 190
        robotx, roboty = robotPositions[0] # 191
 # 192
        # Determine the direction the robot moves. # 193
        if robotx < playerx: # 194
            movex = 1  # Move right. # 195
        elif robotx > playerx: # 196
            movex = -1  # Move left. # 197
        elif robotx == playerx: # 198
            movex = 0  # Don't move horizontally. # 199
 # 200
        if roboty < playery: # 201
            movey = 1  # Move up. # 202
        elif roboty > playery: # 203
            movey = -1  # Move down. # 204
        elif roboty == playery: # 205
            movey = 0  # Don't move vertically. # 206
 # 207
        # Check if the robot would run into a wall, and adjust course: # 208
        if board[(robotx + movex, roboty + movey)] == WALL: # 209
            # Robot would run into a wall, so come up with a new move: # 210
            if board[(robotx + movex, roboty)] == EMPTY_SPACE: # 211
                movey = 0  # Robot can't move horizontally. # 212
            elif board[(robotx, roboty + movey)] == EMPTY_SPACE: # 213
                movex = 0  # Robot can't move vertically. # 214
            else: # 215
                # Robot can't move. # 216
                movex = 0 # 217
                movey = 0 # 218
        newRobotx = robotx + movex # 219
        newRoboty = roboty + movey # 220
 # 221
        if (board[(robotx, roboty)] == DEAD_ROBOT # 222
            or board[(newRobotx, newRoboty)] == DEAD_ROBOT): # 223
            # Robot is at a crash site, remove it. # 224
            del robotPositions[0] # 225
            continue # 226
 # 227
        # Check if it moves into a robot, then destroy both robots: # 228
        if (newRobotx, newRoboty) in nextRobotPositions: # 229
            board[(newRobotx, newRoboty)] = DEAD_ROBOT # 230
            nextRobotPositions.remove((newRobotx, newRoboty)) # 231
        else: # 232
            nextRobotPositions.append((newRobotx, newRoboty)) # 233
 # 234
        # Remove robots from robotPositions as they move. # 235
        del robotPositions[0] # 236
    return nextRobotPositions # 237
 # 238
 # 239
# If this program was run (instead of imported), run the game: # 240
if __name__ == '__main__': # 241
    main()  # 242
```

在输入源代码并运行几次之后，尝试对其进行实验性的修改。标有`(!)`的评论对你可以做的小改变有建议。你也可以自己想办法做到以下几点:

*   创造两种不同的机器人:只能沿对角线移动的机器人和只能沿基本方向移动的机器人。
*   给玩家一定数量的陷阱，他们可以留下来阻止任何机器人踩到陷阱。
*   给玩家有限数量的“瞬间墙”，他们可以建立自己的防御。

## 探索计划

试着找出下列问题的答案。尝试对代码进行一些修改，然后重新运行程序，看看这些修改有什么影响。

1.  如果把第 22 行的`WALL = chr(9617)`改成`WALL = 'R'`会怎么样？
2.  如果把 237 行的`return nextRobotPositions`改成`return robotPositions`会怎么样？
3.  如果删除或注释掉第 44 行的`displayBoard(board, robots, playerPosition)`会发生什么？
4.  如果删除或注释掉第 53 行的`robots = moveRobots(board, robots, playerPosition)`会发生什么？