# #29 森林火灾模拟

> 原文：<http://inventwithpython.com/bigbookpython/project29.html>

![](img/9d995d63aaead72cad01120081eb8f75.png)

这个模拟展示了一个森林，它的树木不断生长，然后被烧毁。在模拟的每一步中，有 1%的可能性一片空白长成一棵树，有 1%的可能性一棵树被闪电击中并烧毁。大火会蔓延到邻近的树木，所以密集的森林比稀疏的森林更容易遭受更大的火灾。这个模拟的灵感来自尼基·凯斯在`ncase.me/simulating/model`的表情符号。

## 行动中的计划

当您运行 `forestfiresim.py` 时，输出将如下所示:

![f29001](img/14feccd29b86617354c4fd6ea863f621.png)

:森林火灾模拟，绿色 `A` s 表示树木，红色 `W` s 表示火焰

## 它是如何工作的

这个模拟是*涌现行为*的一个例子——系统中简单部分之间的相互作用创造了复杂的模式。空地长成树，闪电把树变成火，火又把树变回空地，同时蔓延到邻近的树。通过调整树木生长和雷击率，您可以使森林显示不同的现象。例如，闪电几率低但生长率高会导致持续的大面积森林火灾，因为树木往往彼此靠近并迅速补充。增长率低，但雷击几率高，会引发几起小火灾，但由于附近缺乏树木，这些小火灾很快就会熄灭。我们不会显式地对这些行为进行编程；相反，它自然地从我们创造的系统中出现。

```py
"""Forest Fire Sim, by Al Sweigart email@protected #  1
A simulation of wildfires spreading in a forest. Press Ctrl-C to stop. #  2
Inspired by Nicky Case's Emoji Sim http://ncase.me/simulating/model/ #  3
This code is available at https://nostarch.com/big-book-small-python-programming #  4
Tags: short, bext, simulation""" #  5
 #  6
import random, sys, time #  7
 #  8
try: #  9
   import bext #  10
except ImportError: #  11
   print('This program requires the bext module, which you') #  12
   print('can install by following the instructions at') #  13
   print('https://pypi.org/project/Bext/') #  14
   sys.exit() #  15
 #  16
# Set up the constants: #  17
WIDTH = 79 #  18
HEIGHT = 22 #  19
 #  20
TREE = 'A' #  21
FIRE = 'W' #  22
EMPTY = ' ' #  23
 #  24
# (!) Try changing these settings to anything between 0.0 and 1.0: #  25
INITIAL_TREE_DENSITY = 0.20  # Amount of forest that starts with trees. #  26
GROW_CHANCE = 0.01  # Chance a blank space turns into a tree. #  27
FIRE_CHANCE = 0.01  # Chance a tree is hit by lightning & burns. #  28
 #  29
# (!) Try setting the pause length to 1.0 or 0.0: #  30
PAUSE_LENGTH = 0.5 #  31
 #  32
 #  33
def main(): #  34
   forest = createNewForest() #  35
   bext.clear() #  36
 #  37
   while True:  # Main program loop. #  38
       displayForest(forest) #  39
 #  40
       # Run a single simulation step: #  41
       nextForest = {'width': forest['width'], #  42
                     'height': forest['height']} #  43
 #  44
       for x in range(forest['width']): #  45
           for y in range(forest['height']): #  46
               if (x, y) in nextForest: #  47
                   # If we've already set nextForest[(x, y)] on a #  48
                   # previous iteration, just do nothing here: #  49
                   continue #  50
 #  51
               if ((forest[(x, y)] == EMPTY) #  52
                   and (random.random() <= GROW_CHANCE)): #  53
                   # Grow a tree in this empty space. #  54
                   nextForest[(x, y)] = TREE #  55
               elif ((forest[(x, y)] == TREE) #  56
                   and (random.random() <= FIRE_CHANCE)): #  57
                   # Lightning sets this tree on fire. #  58
                   nextForest[(x, y)] = FIRE #  59
               elif forest[(x, y)] == FIRE: #  60
                   # This tree is currently burning. #  61
                   # Loop through all the neighboring spaces: #  62
                   for ix in range(-1, 2): #  63
                       for iy in range(-1, 2): #  64
                           # Fire spreads to neighboring trees: #  65
                           if forest.get((x + ix, y + iy)) == TREE: #  66
                               nextForest[(x + ix, y + iy)] = FIRE #  67
                   # The tree has burned down now, so erase it: #  68
                   nextForest[(x, y)] = EMPTY #  69
               else: #  70
                   # Just copy the existing object: #  71
                   nextForest[(x, y)] = forest[(x, y)] #  72
       forest = nextForest #  73
 #  74
       time.sleep(PAUSE_LENGTH) #  75
 #  76
 #  77
def createNewForest(): #  78
   """Returns a dictionary for a new forest data structure.""" #  79
   forest = {'width': WIDTH, 'height': HEIGHT} #  80
   for x in range(WIDTH): #  81
       for y in range(HEIGHT): #  82
           if (random.random() * 100) <= INITIAL_TREE_DENSITY: #  83
               forest[(x, y)] = TREE  # Start as a tree. #  84
           else: #  85
               forest[(x, y)] = EMPTY  # Start as an empty space. #  86
   return forest #  87
 #  88
 #  89
def displayForest(forest): #  90
   """Display the forest data structure on the screen.""" #  91
   bext.goto(0, 0) #  92
   for y in range(forest['height']): #  93
       for x in range(forest['width']): #  94
           if forest[(x, y)] == TREE: #  95
               bext.fg('green') #  96
               print(TREE, end='') #  97
           elif forest[(x, y)] == FIRE: #  98
               bext.fg('red') #  99
                print(FIRE, end='') # 100
            elif forest[(x, y)] == EMPTY: # 101
                print(EMPTY, end='') # 102
        print() # 103
    bext.fg('reset')  # Use the default font color. # 104
    print('Grow chance: {}%  '.format(GROW_CHANCE * 100), end='') # 105
    print('Lightning chance: {}%  '.format(FIRE_CHANCE * 100), end='') # 106
    print('Press Ctrl-C to quit.') # 107
 # 108
 # 109
# If this program was run (instead of imported), run the game: # 110
if __name__ == '__main__': # 111
    try: # 112
        main() # 113
    except KeyboardInterrupt: # 114
        sys.exit()  # When Ctrl-C is pressed, end the program.  # 115
```

在输入源代码并运行几次之后，尝试对其进行实验性的修改。标有`(!)`的评论对你可以做的小改变有建议。你也可以自己想办法做到以下几点:

*   添加随机创建的湖泊和河流，作为火焰无法穿越的防火屏障。
*   加上一棵树从它的邻居那里着火的百分比几率。
*   添加不同种类的树，着火几率不同。
*   添加燃烧树木的不同状态，以便一棵树被烧毁需要多个模拟步骤。

## 探索计划

试着找出下列问题的答案。尝试对代码进行一些修改，然后重新运行程序，看看这些修改有什么影响。

1.  如果把第 96 行的`bext.fg('green')`改成`bext.fg('random')`会怎么样？
2.  如果把第 23 行的`EMPTY = ' '`改成`EMPTY = '.'`会怎么样？
3.  如果把第 66 行的`forest.get((x + ix, y + iy)) == TREE`改成`forest.get((x + ix, y + iy)) == EMPTY`会怎么样？
4.  如果把第 69 行的`nextForest[(x, y)] = EMPTY`改成`nextForest[(x, y)] = FIRE`会怎么样？
5.  如果把 86 行的`forest[(x, y)] = EMPTY`改成`forest[(x, y)] = TREE`会怎么样？