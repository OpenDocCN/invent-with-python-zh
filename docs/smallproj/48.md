# #47 蒙德里安艺术生成器

> 原文：<http://inventwithpython.com/bigbookpython/project47.html>

![](img/9d995d63aaead72cad01120081eb8f75.png)

皮耶·蒙德里安是 20 世纪的荷兰画家，也是抽象艺术运动“新塑料主义”的创始人之一。他最具标志性的画作依赖于原色(蓝、黄、红)、黑色和白色。他采用极简主义的方法，用水平和垂直的元素将这些颜色分开。

这个程序随机生成遵循蒙德里安风格的绘画。你可以在`en.wikipedia.org/wiki/Piet_Mondrian`找到更多关于皮特·蒙德里安的信息。

## 行动中的计划

`bext`模块允许我们的 Python 程序在文本输出中显示明亮的原色，尽管这本书只显示黑白图像。[图 47-1](#calibre_link-342) 显示了运行 `mondrian.py` 时的输出。

![f47001](img/785dc44ec461df99c039eed5bd6b60ab.png)

图 47-1 :蒙德里安艺术程序的计算机生成艺术。程序每次运行都会生成不同的图像。

## 它是如何工作的

该算法通过创建一个带有随机间隔的垂直线和水平线的数据结构(`canvas`字典)来工作，如图[图 47-2](#calibre_link-343) 。

![f47002](img/accc21534ee0beaf24e689dfc199d786.png)

:蒙德里安艺术算法的第一步是创建一个网格。

接下来，它移除一些线段来创建更大的矩形，如图[图 47-3](#calibre_link-344) 所示。

![f47003](img/66fecc2871d9dc03863daf6b264ad412.png)

:蒙德里安艺术算法的第二步随机去掉一些线条。

最后，算法用黄色、红色、蓝色或黑色随机填充一些矩形，如图[图 47-4](#calibre_link-345) 。

![f47004](img/374aab98801c59fabc81ed00211ad535.png)

:蒙德里安艺术算法第三步随机选择矩形填充颜色。

你可以在`github.com/asweigart/mondrian_art_generator`找到这个蒙德里安艺术生成器的另一个版本，还有一些样本图片。

```py
"""Mondrian Art Generator, by Al Sweigart email@protected #  1
Randomly generates art in the style of Piet Mondrian. #  2
More info at: https://en.wikipedia.org/wiki/Piet_Mondrian #  3
This code is available at https://nostarch.com/big-book-small-python-programming #  4
Tags: large, artistic, bext""" #  5
 #  6
import sys, random #  7
 #  8
try: #  9
   import bext #  10
except ImportError: #  11
   print('This program requires the bext module, which you') #  12
   print('can install by following the instructions at') #  13
   print('https://pypi.org/project/Bext/') #  14
   sys.exit() #  15
 #  16
# Set up the constants: #  17
MIN_X_INCREASE = 6 #  18
MAX_X_INCREASE = 16 #  19
MIN_Y_INCREASE = 3 #  20
MAX_Y_INCREASE = 6 #  21
WHITE = 'white' #  22
BLACK = 'black' #  23
RED = 'red' #  24
YELLOW = 'yellow' #  25
BLUE = 'blue' #  26
 #  27
# Setup the screen: #  28
width, height = bext.size() #  29
# We can't print to the last column on Windows without it adding a #  30
# newline automatically, so reduce the width by one: #  31
width -= 1 #  32
 #  33
height -= 3 #  34
 #  35
while True:  # Main application loop. #  36
   # Pre-populate the canvas with blank spaces: #  37
   canvas = {} #  38
   for x in range(width): #  39
       for y in range(height): #  40
           canvas[(x, y)] = WHITE #  41
 #  42
   # Generate vertical lines: #  43
   numberOfSegmentsToDelete = 0 #  44
   x = random.randint(MIN_X_INCREASE, MAX_X_INCREASE) #  45
   while x < width - MIN_X_INCREASE: #  46
       numberOfSegmentsToDelete += 1 #  47
       for y in range(height): #  48
           canvas[(x, y)] = BLACK #  49
       x += random.randint(MIN_X_INCREASE, MAX_X_INCREASE) #  50
 #  51
   # Generate horizontal lines: #  52
   y = random.randint(MIN_Y_INCREASE, MAX_Y_INCREASE) #  53
   while y < height - MIN_Y_INCREASE: #  54
       numberOfSegmentsToDelete += 1 #  55
       for x in range(width): #  56
           canvas[(x, y)] = BLACK #  57
       y += random.randint(MIN_Y_INCREASE, MAX_Y_INCREASE) #  58
 #  59
   numberOfRectanglesToPaint = numberOfSegmentsToDelete - 3 #  60
   numberOfSegmentsToDelete = int(numberOfSegmentsToDelete * 1.5) #  61
 #  62
   # Randomly select points and try to remove them. #  63
   for i in range(numberOfSegmentsToDelete): #  64
       while True:  # Keep selecting segments to try to delete. #  65
           # Get a random start point on an existing segment: #  66
           startx = random.randint(1, width - 2) #  67
           starty = random.randint(1, height - 2) #  68
           if canvas[(startx, starty)] == WHITE: #  69
               continue #  70
 #  71
           # Find out if we're on a vertical or horizontal segment: #  72
           if (canvas[(startx - 1, starty)] == WHITE and #  73
               canvas[(startx + 1, starty)] == WHITE): #  74
               orientation = 'vertical' #  75
           elif (canvas[(startx, starty - 1)] == WHITE and #  76
               canvas[(startx, starty + 1)] == WHITE): #  77
               orientation = 'horizontal' #  78
           else: #  79
               # The start point is on an intersection, #  80
               # so get a new random start point: #  81
               continue #  82
 #  83
           pointsToDelete = [(startx, starty)] #  84
 #  85
           canDeleteSegment = True #  86
           if orientation == 'vertical': #  87
               # Go up one path from the start point, and #  88
               # see if we can remove this segment: #  89
               for changey in (-1, 1): #  90
                   y = starty #  91
                   while 0 < y < height - 1: #  92
                       y += changey #  93
                       if (canvas[(startx - 1, y)] == BLACK and #  94
                           canvas[(startx + 1, y)] == BLACK): #  95
                           # We've found a four-way intersection. #  96
                           break #  97
                       elif ((canvas[(startx - 1, y)] == WHITE and #  98
                              canvas[(startx + 1, y)] == BLACK) or #  99
                              (canvas[(startx - 1, y)] == BLACK and # 100
                               canvas[(startx + 1, y)] == WHITE)): # 101
                            # We've found a T-intersection; we can't # 102
                            # delete this segment: # 103
                            canDeleteSegment = False # 104
                            break # 105
                        else: # 106
                            pointsToDelete.append((startx, y)) # 107
 # 108
            elif orientation == 'horizontal': # 109
                # Go up one path from the start point, and # 110
                # see if we can remove this segment: # 111
                for changex in (-1, 1): # 112
                    x = startx # 113
                    while 0 < x < width - 1: # 114
                        x += changex # 115
                        if (canvas[(x, starty - 1)] == BLACK and # 116
                            canvas[(x, starty + 1)] == BLACK): # 117
                            # We've found a four-way intersection. # 118
                            break # 119
                        elif ((canvas[(x, starty - 1)] == WHITE and # 120
                               canvas[(x, starty + 1)] == BLACK) or # 121
                              (canvas[(x, starty - 1)] == BLACK and # 122
                               canvas[(x, starty + 1)] == WHITE)): # 123
                            # We've found a T-intersection; we can't # 124
                            # delete this segment: # 125
                            canDeleteSegment = False # 126
                            break # 127
                        else: # 128
                            pointsToDelete.append((x, starty)) # 129
            if not canDeleteSegment: # 130
                continue  # Get a new random start point. # 131
            break  # Move on to delete the segment. # 132
 # 133
        # If we can delete this segment, set all the points to white: # 134
        for x, y in pointsToDelete: # 135
            canvas[(x, y)] = WHITE # 136
 # 137
    # Add the border lines: # 138
    for x in range(width): # 139
        canvas[(x, 0)] = BLACK  # Top border. # 140
        canvas[(x, height - 1)] = BLACK  # Bottom border. # 141
    for y in range(height): # 142
        canvas[(0, y)] = BLACK  # Left border. # 143
        canvas[(width - 1, y)] = BLACK  # Right border. # 144
 # 145
    # Paint the rectangles: # 146
    for i in range(numberOfRectanglesToPaint): # 147
        while True: # 148
            startx = random.randint(1, width - 2) # 149
            starty = random.randint(1, height - 2) # 150
 # 151
            if canvas[(startx, starty)] != WHITE: # 152
                continue  # Get a new random start point. # 153
            else: # 154
                break # 155
 # 156
        # Flood fill algorithm: # 157
        colorToPaint = random.choice([RED, YELLOW, BLUE, BLACK]) # 158
        pointsToPaint = set([(startx, starty)]) # 159
        while len(pointsToPaint) > 0: # 160
            x, y = pointsToPaint.pop() # 161
            canvas[(x, y)] = colorToPaint # 162
            if canvas[(x - 1, y)] == WHITE: # 163
                pointsToPaint.add((x - 1, y)) # 164
            if canvas[(x + 1, y)] == WHITE: # 165
                pointsToPaint.add((x + 1, y)) # 166
            if canvas[(x, y - 1)] == WHITE: # 167
                pointsToPaint.add((x, y - 1)) # 168
            if canvas[(x, y + 1)] == WHITE: # 169
                pointsToPaint.add((x, y + 1)) # 170
 # 171
    # Draw the canvas data structure: # 172
    for y in range(height): # 173
        for x in range(width): # 174
            bext.bg(canvas[(x, y)]) # 175
            print(' ', end='') # 176
 # 177
        print() # 178
 # 179
    # Prompt user to create a new one: # 180
    try: # 181
        input('Press Enter for another work of art, or Ctrl-C to quit.') # 182
    except KeyboardInterrupt: # 183
        sys.exit()  # 184
```

在输入源代码并运行几次之后，尝试对其进行实验性的修改。你也可以自己想办法做到以下几点:

*   用不同的调色板创建程序。
*   使用`Pillow`模块制作蒙德里安艺术的图像文件。你可以从《Python 自动化指南》第 19 章了解这个模块，[`automatetheboringstuff.com/2e/chapter19`](https://automatetheboringstuff.com/2e/chapter19/)。

## 探索计划

试着找出下列问题的答案。尝试对代码进行一些修改，然后重新运行程序，看看这些修改有什么影响。

1.  如果把第 41 行的`canvas[(x, y)] = WHITE`改成`canvas[(x, y)] = RED`会出现什么错误？
2.  如果把 176 行的`print(' ', end='')`改成`print('A', end='')`会怎么样？