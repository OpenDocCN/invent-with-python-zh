# #36 沙漏

> 原文：<http://inventwithpython.com/bigbookpython/project36.html>

![](img/9d995d63aaead72cad01120081eb8f75.png)

这个可视化程序有一个粗糙的物理引擎，模拟沙子通过沙漏的小孔落下。沙子堆积在沙漏的下半部分；然后把沙漏翻过来，重复这个过程。

## 行动中的计划

图 36-1 显示了运行`hourglass.py`时的输出。

![f36001](img/15e1daa91d334672458254f0c8896454.png)

:沙漏程序在落砂时的输出

## 它是如何工作的

沙漏程序实现了一个基本的物理引擎。一个*物理引擎*是模拟物理物体在重力作用下下落，相互碰撞，按照物理定律运动的软件。你会发现在视频游戏、计算机动画和科学模拟中使用的物理引擎。在第 91 到 102 行，每一粒沙子检查它下面的空间是否是空的，如果是，就向下移动。否则，它检查它是否可以向左下方移动(第 104 到 112 行)或向右下方移动(第 114 到 122 行)。当然，*运动学*，经典物理学的一个分支，处理宏观物体的运动，远不止这些。然而，你不需要一个物理学学位来制作一个沙漏中沙子的原始模拟，它看起来是令人愉快的。

```py
"""Hourglass, by Al Sweigart email@protected #  1
An animation of an hourglass with falling sand. Press Ctrl-C to stop. #  2
This code is available at https://nostarch.com/big-book-small-python-programming #  3
Tags: large, artistic, bext, simulation""" #  4
 #  5
import random, sys, time #  6
 #  7
try: #  8
   import bext #  9
except ImportError: #  10
   print('This program requires the bext module, which you') #  11
   print('can install by following the instructions at') #  12
   print('https://pypi.org/project/Bext/') #  13
   sys.exit() #  14
 #  15
# Set up the constants: #  16
PAUSE_LENGTH = 0.2  # (!) Try changing this to 0.0 or 1.0. #  17
# (!) Try changing this to any number between 0 and 100: #  18
WIDE_FALL_CHANCE = 50 #  19
 #  20
SCREEN_WIDTH = 79 #  21
SCREEN_HEIGHT = 25 #  22
X = 0  # The index of X values in an (x, y) tuple is 0. #  23
Y = 1  # The index of Y values in an (x, y) tuple is 1. #  24
SAND = chr(9617) #  25
WALL = chr(9608) #  26
 #  27
# Set up the walls of the hour glass: #  28
HOURGLASS = set()  # Has (x, y) tuples for where hourglass walls are. #  29
# (!) Try commenting out some HOURGLASS.add() lines to erase walls: #  30
for i in range(18, 37): #  31
   HOURGLASS.add((i, 1))  # Add walls for the top cap of the hourglass. #  32
   HOURGLASS.add((i, 23))  # Add walls for the bottom cap. #  33
for i in range(1, 5): #  34
   HOURGLASS.add((18, i))  # Add walls for the top left straight wall. #  35
   HOURGLASS.add((36, i))  # Add walls for the top right straight wall. #  36
   HOURGLASS.add((18, i + 19))  # Add walls for the bottom left. #  37
   HOURGLASS.add((36, i + 19))  # Add walls for the bottom right. #  38
for i in range(8): #  39
   HOURGLASS.add((19 + i, 5 + i))  # Add the top left slanted wall. #  40
   HOURGLASS.add((35 - i, 5 + i))  # Add the top right slanted wall. #  41
   HOURGLASS.add((25 - i, 13 + i))  # Add the bottom left slanted wall. #  42
   HOURGLASS.add((29 + i, 13 + i))  # Add the bottom right slanted wall. #  43
 #  44
# Set up the initial sand at the top of the hourglass: #  45
INITIAL_SAND = set() #  46
for y in range(8): #  47
   for x in range(19 + y, 36 - y): #  48
       INITIAL_SAND.add((x, y + 4)) #  49
 #  50
 #  51
def main(): #  52
   bext.fg('yellow') #  53
   bext.clear() #  54
 #  55
   # Draw the quit message: #  56
   bext.goto(0, 0) #  57
   print('Ctrl-C to quit.', end='') #  58
 #  59
   # Display the walls of the hourglass: #  60
   for wall in HOURGLASS: #  61
       bext.goto(wall[X], wall[Y]) #  62
       print(WALL, end='') #  63
 #  64
   while True:  # Main program loop. #  65
       allSand = list(INITIAL_SAND) #  66
 #  67
       # Draw the initial sand: #  68
       for sand in allSand: #  69
           bext.goto(sand[X], sand[Y]) #  70
           print(SAND, end='') #  71
 #  72
       runHourglassSimulation(allSand) #  73
 #  74
 #  75
def runHourglassSimulation(allSand): #  76
   """Keep running the sand falling simulation until the sand stops #  77
   moving.""" #  78
   while True:  # Keep looping until sand has run out. #  79
       random.shuffle(allSand)  # Random order of grain simulation. #  80
 #  81
       sandMovedOnThisStep = False #  82
       for i, sand in enumerate(allSand): #  83
           if sand[Y] == SCREEN_HEIGHT - 1: #  84
               # Sand is on the very bottom, so it won't move: #  85
               continue #  86
 #  87
           # If nothing is under this sand, move it down: #  88
           noSandBelow = (sand[X], sand[Y] + 1) not in allSand #  89
           noWallBelow = (sand[X], sand[Y] + 1) not in HOURGLASS #  90
           canFallDown = noSandBelow and noWallBelow #  91
 #  92
           if canFallDown: #  93
               # Draw the sand in its new position down one space: #  94
               bext.goto(sand[X], sand[Y]) #  95
               print(' ', end='')  # Clear the old position. #  96
               bext.goto(sand[X], sand[Y] + 1) #  97
               print(SAND, end='') #  98
 #  99
                # Set the sand in its new position down one space: # 100
                allSand[i] = (sand[X], sand[Y] + 1) # 101
                sandMovedOnThisStep = True # 102
            else: # 103
                # Check if the sand can fall to the left: # 104
                belowLeft = (sand[X] - 1, sand[Y] + 1) # 105
                noSandBelowLeft = belowLeft not in allSand # 106
                noWallBelowLeft = belowLeft not in HOURGLASS # 107
                left = (sand[X] - 1, sand[Y]) # 108
                noWallLeft = left not in HOURGLASS # 109
                notOnLeftEdge = sand[X] > 0 # 110
                canFallLeft = (noSandBelowLeft and noWallBelowLeft # 111
                    and noWallLeft and notOnLeftEdge) # 112
 # 113
                # Check if the sand can fall to the right: # 114
                belowRight = (sand[X] + 1, sand[Y] + 1) # 115
                noSandBelowRight = belowRight not in allSand # 116
                noWallBelowRight = belowRight not in HOURGLASS # 117
                right = (sand[X] + 1, sand[Y]) # 118
                noWallRight = right not in HOURGLASS # 119
                notOnRightEdge = sand[X] < SCREEN_WIDTH - 1 # 120
                canFallRight = (noSandBelowRight and noWallBelowRight # 121
                    and noWallRight and notOnRightEdge) # 122
 # 123
                # Set the falling direction: # 124
                fallingDirection = None # 125
                if canFallLeft and not canFallRight: # 126
                    fallingDirection = -1  # Set the sand to fall left. # 127
                elif not canFallLeft and canFallRight: # 128
                    fallingDirection = 1  # Set the sand to fall right. # 129
                elif canFallLeft and canFallRight: # 130
                    # Both are possible, so randomly set it: # 131
                    fallingDirection = random.choice((-1, 1)) # 132
 # 133
                # Check if the sand can "far" fall two spaces to # 134
                # the left or right instead of just one space: # 135
                if random.random() * 100 <= WIDE_FALL_CHANCE: # 136
                    belowTwoLeft = (sand[X] - 2, sand[Y] + 1) # 137
                    noSandBelowTwoLeft = belowTwoLeft not in allSand # 138
                    noWallBelowTwoLeft = belowTwoLeft not in HOURGLASS # 139
                    notOnSecondToLeftEdge = sand[X] > 1 # 140
                    canFallTwoLeft = (canFallLeft and noSandBelowTwoLeft # 141
                        and noWallBelowTwoLeft and notOnSecondToLeftEdge) # 142
 # 143
                    belowTwoRight = (sand[X] + 2, sand[Y] + 1) # 144
                    noSandBelowTwoRight = belowTwoRight not in allSand # 145
                    noWallBelowTwoRight = belowTwoRight not in HOURGLASS # 146
                    notOnSecondToRightEdge = sand[X] < SCREEN_WIDTH - 2 # 147
                    canFallTwoRight = (canFallRight # 148
                        and noSandBelowTwoRight and noWallBelowTwoRight # 149
                        and notOnSecondToRightEdge) # 150
 # 151
                    if canFallTwoLeft and not canFallTwoRight: # 152
                        fallingDirection = -2 # 153
                    elif not canFallTwoLeft and canFallTwoRight: # 154
                        fallingDirection = 2 # 155
                    elif canFallTwoLeft and canFallTwoRight: # 156
                        fallingDirection = random.choice((-2, 2)) # 157
 # 158
                if fallingDirection == None: # 159
                    # This sand can't fall, so move on. # 160
                    continue # 161
 # 162
                # Draw the sand in its new position: # 163
                bext.goto(sand[X], sand[Y]) # 164
                print(' ', end='')  # Erase old sand. # 165
                bext.goto(sand[X] + fallingDirection, sand[Y] + 1) # 166
                print(SAND, end='')  # Draw new sand. # 167
 # 168
                # Move the grain of sand to its new position: # 169
                allSand[i] = (sand[X] + fallingDirection, sand[Y] + 1) # 170
                sandMovedOnThisStep = True # 171
 # 172
        sys.stdout.flush()  # (Required for bext-using programs.) # 173
        time.sleep(PAUSE_LENGTH)  # Pause after this # 174
 # 175
        # If no sand has moved on this step, reset the hourglass: # 176
        if not sandMovedOnThisStep: # 177
            time.sleep(2) # 178
            # Erase all of the sand: # 179
            for sand in allSand: # 180
                bext.goto(sand[X], sand[Y]) # 181
                print(' ', end='') # 182
            break  # Break out of main simulation loop. # 183
 # 184
 # 185
# If this program was run (instead of imported), run the game: # 186
if __name__ == '__main__': # 187
    try: # 188
        main() # 189
    except KeyboardInterrupt: # 190
        sys.exit()  # When Ctrl-C is pressed, end the program.  # 191
```

在输入源代码并运行几次之后，尝试对其进行实验性的修改。标有`(!)`的评论对你可以做的小改变有建议。你也可以自己想办法做到以下几点:

*   创建除沙漏以外的墙壁形状。
*   在屏幕上创建点，不断涌出新的沙粒。

## 探索计划

试着找出下列问题的答案。尝试对代码进行一些修改，然后重新运行程序，看看这些修改有什么影响。

1.  如果把第 31 行的`range(18, 37)`改成`range(18, 30)`会怎么样？
2.  如果把第 39 行的`range(8)`改成`range(0)`会怎么样？
3.  如果把第 82 行的`sandMovedOnThisStep = False`改成`sandMovedOnThisStep = True`会怎么样？
4.  如果把 125 行的`fallingDirection = None`改成`fallingDirection = 1`会怎么样？
5.  如果把 136 行的`random.random() * 100 <= WIDE_FALL_CHANCE`改成`random.random() * 0 <= WIDE_FALL_CHANCE`会怎么样？