# #68 滑动拼图

> 原文：<http://inventwithpython.com/bigbookpython/project68.html>

![](img/9d995d63aaead72cad01120081eb8f75.png)

这个经典的难题依赖于一个 4 × 4 的板，有 15 个编号的瓷砖和一个自由空间。目标是滑动瓷砖，直到数字按正确的顺序排列，从左到右，从上到下。瓷砖只能滑动；不允许你直接拿起来重新排列。这个益智玩具的一些版本的特点是混乱的图像，一旦解决就形成一个完整的图片。

更多关于滑动拼图的信息可以在[`en.wikipedia.org/wiki/Sliding_puzzle`](https://en.wikipedia.org/wiki/Sliding_puzzle)找到。

## 行动中的计划

当您运行 `slidingtilepuzzle.py` 时，输出将如下所示:

```py
Sliding Tile Puzzle, by Al Sweigart email@protected

    Use the WASD keys to move the tiles
    back into their original order:
           1  2  3  4
           5  6  7  8
           9 10 11 12
          13 14 15
Press Enter to begin...

+------+------+------+------+
|      |      |      |      |
|  5   |  10  |      |  11  |
|      |      |      |      |
+------+------+------+------+
|      |      |      |      |
|  6   |  3   |  7   |  2   |
|      |      |      |      |
+------+------+------+------+
|      |      |      |      |
|  14  |  1   |  15  |  8   |
|      |      |      |      |
+------+------+------+------+
|      |      |      |      |
|  9   |  13  |  4   |  12  |
|      |      |      |      |
+------+------+------+------+

                          (W)
Enter WASD (or QUIT): (A) ( ) (D)
> w

+------+------+------+------+
|      |      |      |      |
|  5   |  10  |  7   |  11  |
|      |      |      |      |
+------+------+------+------+
|      |      |      |      |
|  6   |  3   |      |  2   |
|      |      |      |      |
+------+------+------+------+
|      |      |      |      |
|  14  |  1   |  15  |  8   |
|      |      |      |      |
+------+------+------+------+
|      |      |      |      |
|  9   |  13  |  4   |  12  |
|      |      |      |      |
+------+------+------+------+

                          (W)
Enter WASD (or QUIT): (A) (S) (D)
`--snip--`
```

## 它是如何工作的

表示滑动瓦片游戏板的数据结构是列表的列表。每个内部列表代表 4 × 4 棋盘的一列，并包含编号方块的字符串(或代表空白空间的`BLANK`字符串)。`getNewBoard()`函数返回列表的列表，所有的图块都在它们的起始位置，在右下角有一个空格。

Python 可以用类似于`a, b = b, a`的语句交换两个变量的值。该程序在第 101 到 108 行使用这种技术来交换空白空间和相邻的图块，并模拟将编号的图块滑入空白空间。`getNewPuzzle()`函数通过随机执行 200 次这样的交换来生成新的谜题。

```py
"""Sliding Tile Puzzle, by Al Sweigart email@protected #  1
Slide the numbered tiles into the correct order. #  2
This code is available at https://nostarch.com/big-book-small-python-programming #  3
Tags: large, game, puzzle""" #  4
 #  5
import random, sys #  6
 #  7
BLANK = '  '  # Note: This string is two spaces, not one. #  8
 #  9
 #  10
def main(): #  11
   print('''Sliding Tile Puzzle, by Al Sweigart email@protected #  12
 #  13
   Use the WASD keys to move the tiles #  14
   back into their original order: #  15
          1  2  3  4 #  16
          5  6  7  8 #  17
          9 10 11 12 #  18
         13 14 15   ''') #  19
   input('Press Enter to begin...') #  20
 #  21
   gameBoard = getNewPuzzle() #  22
 #  23
   while True: #  24
       displayBoard(gameBoard) #  25
       playerMove = askForPlayerMove(gameBoard) #  26
       makeMove(gameBoard, playerMove) #  27
 #  28
       if gameBoard == getNewBoard(): #  29
           print('You won!') #  30
           sys.exit() #  31
 #  32
 #  33
def getNewBoard(): #  34
   """Return a list of lists that represents a new tile puzzle.""" #  35
   return [['1 ', '5 ', '9 ', '13'], ['2 ', '6 ', '10', '14'], #  36
           ['3 ', '7 ', '11', '15'], ['4 ', '8 ', '12', BLANK]] #  37
 #  38
 #  39
def displayBoard(board): #  40
   """Display the given board on the screen.""" #  41
   labels = [board[0][0], board[1][0], board[2][0], board[3][0], #  42
             board[0][1], board[1][1], board[2][1], board[3][1], #  43
             board[0][2], board[1][2], board[2][2], board[3][2], #  44
             board[0][3], board[1][3], board[2][3], board[3][3]] #  45
   boardToDraw = """ #  46
+------+------+------+------+ #  47
|      |      |      |      | #  48
| {} | {} | {} | {} | #  49
|      |      |      |      | #  50
+------+------+------+------+ #  51
|      |      |      |      | #  52
| {} | {} | {} | {} | #  53
|      |      |      |      | #  54
+------+------+------+------+ #  55
|      |      |      |      | #  56
| {} | {} | {} | {} | #  57
|      |      |      |      | #  58
+------+------+------+------+ #  59
|      |      |      |      | #  60
| {} | {} | {} | {} | #  61
|      |      |      |      | #  62
+------+------+------+------+ #  63
""".format(*labels) #  64
   print(boardToDraw) #  65
 #  66
 #  67
def findBlankSpace(board): #  68
   """Return an (x, y) tuple of the blank space's location.""" #  69
   for x in range(4): #  70
       for y in range(4): #  71
           if board[x][y] == '  ': #  72
               return (x, y) #  73
 #  74
 #  75
def askForPlayerMove(board): #  76
   """Let the player select a tile to slide.""" #  77
   blankx, blanky = findBlankSpace(board) #  78
 #  79
   w = 'W' if blanky != 3 else ' ' #  80
   a = 'A' if blankx != 3 else ' ' #  81
   s = 'S' if blanky != 0 else ' ' #  82
   d = 'D' if blankx != 0 else ' ' #  83
 #  84
   while True: #  85
       print('                          ({})'.format(w)) #  86
       print('Enter WASD (or QUIT): ({}) ({}) ({})'.format(a, s, d)) #  87
 #  88
       response = input('> ').upper() #  89
       if response == 'QUIT': #  90
           sys.exit() #  91
       if response in (w + a + s + d).replace(' ', ''): #  92
           return response #  93
 #  94
 #  95
def makeMove(board, move): #  96
   """Carry out the given move on the given board.""" #  97
   # Note: This function assumes that the move is valid. #  98
   bx, by = findBlankSpace(board) #  99
 # 100
    if move == 'W': # 101
        board[bx][by], board[bx][by+1] = board[bx][by+1], board[bx][by] # 102
    elif move == 'A': # 103
        board[bx][by], board[bx+1][by] = board[bx+1][by], board[bx][by] # 104
    elif move == 'S': # 105
        board[bx][by], board[bx][by-1] = board[bx][by-1], board[bx][by] # 106
    elif move == 'D': # 107
        board[bx][by], board[bx-1][by] = board[bx-1][by], board[bx][by] # 108
 # 109
 # 110
def makeRandomMove(board): # 111
    """Perform a slide in a random direction.""" # 112
    blankx, blanky = findBlankSpace(board) # 113
    validMoves = [] # 114
    if blanky != 3: # 115
        validMoves.append('W') # 116
    if blankx != 3: # 117
        validMoves.append('A') # 118
    if blanky != 0: # 119
        validMoves.append('S') # 120
    if blankx != 0: # 121
        validMoves.append('D') # 122
 # 123
    makeMove(board, random.choice(validMoves)) # 124
 # 125
 # 126
def getNewPuzzle(moves=200): # 127
    """Get a new puzzle by making random slides from a solved state.""" # 128
    board = getNewBoard() # 129
 # 130
    for i in range(moves): # 131
        makeRandomMove(board) # 132
    return board # 133
 # 134
 # 135
# If this program was run (instead of imported), run the game: # 136
if __name__ == '__main__': # 137
    main()  # 138
```

在输入源代码并运行几次之后，尝试对其进行实验性的修改。你也可以自己想办法做到以下几点:

*   创建一个更困难的 5 × 5 变种的滑动瓷砖拼图。
*   创建一个“自动解决”模式，保存当前的瓷砖排列，然后尝试多达 40 个随机移动和停止，如果他们已经解决了难题。否则，拼图将加载保存的状态，并尝试另外 40 次随机移动。

## 探索计划

试着找出下列问题的答案。尝试对代码进行一些修改，然后重新运行程序，看看这些修改有什么影响。

1.  如果把第 22 行的`getNewPuzzle()`改成`getNewPuzzle(1)`会怎么样？
2.  如果把第 22 行的`getNewPuzzle()`改成`getNewPuzzle(0)`会怎么样？
3.  如果删除或注释掉第 31 行的`sys.exit()`会发生什么？