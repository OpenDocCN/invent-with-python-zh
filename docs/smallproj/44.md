# 曼卡拉 43 号

> 原文：<http://inventwithpython.com/bigbookpython/project43.html>

![](img/9d995d63aaead72cad01120081eb8f75.png)

棋盘游戏曼卡拉至少有 2000 年的历史，几乎和 63 号项目“乌尔的皇家游戏”一样古老这是一种“播种”游戏，两名玩家选择几袋种子，撒在棋盘上的其他口袋里，同时尽可能多地收集他们商店里的种子。在不同的文化中，这种游戏有几种变体。这个名字来自阿拉伯语 `naqala` ，意思是“移动”

玩的时候，从你这边的一个坑里抓种子，然后在每个坑里放一个，逆时针方向走，跳过你对手的仓库。如果你的最后一粒种子落在你的一个空坑里，将对面坑的种子移到那个坑里。如果最后放置的种子在你的商店里，你有一次免费机会。

当一个玩家的所有坑都空了时，游戏结束。另一名玩家声称剩余的种子属于他们的商店，获胜者是拥有最多种子的人。更多关于曼卡拉及其变种的信息可以在[`en.wikipedia.org/wiki/Mancala`](https://en.wikipedia.org/wiki/Mancala)找到。

## 行动中的计划

当您运行 `mancala.py` 时，输出将如下所示:

```py
Mancala, by Al Sweigart email@protected
`--snip--`

+------+------+--<<<<<-Player 2----+------+------+------+
2      |G     |H     |I     |J     |K     |L     |      1
       |   4  |   4  |   4  |   4  |   4  |   4  |
S      |      |      |      |      |      |      |      S
T   0  +------+------+------+------+------+------+   0  T
O      |A     |B     |C     |D     |E     |F     |      O
R      |   4  |   4  |   4  |   4  |   4  |   4  |      R
E      |      |      |      |      |      |      |      E
+------+------+------+-Player 1->>>>>-----+------+------+

Player 1, choose move: A-F (or QUIT)
> f

+------+------+--<<<<<-Player 2----+------+------+------+
2      |G     |H     |I     |J     |K     |L     |      1
       |   4  |   4  |   4  |   5  |   5  |   5  |
S      |      |      |      |      |      |      |      S
T   0  +------+------+------+------+------+------+   1  T
O      |A     |B     |C     |D     |E     |F     |      O
R      |   4  |   4  |   4  |   4  |   4  |   0  |      R
E      |      |      |      |      |      |      |      E
+------+------+------+-Player 1->>>>>-----+------+------+
Player 2, choose move: G-L (or QUIT)
`--snip--`
```

## 它是如何工作的

Mancala 使用 ASCII 艺术来显示棋盘。请注意，每个口袋不仅需要有种子的数量，还需要有一个标签。为了避免混淆，标签上使用了从`A`到`L`的字母，这样就不会被误认为是每个口袋里的种子数量。字典`NEXT_PIT`和`OPPOSITE_PIT`分别将一个口袋的字母映射到它旁边或对面的坑的字母。这使得表达式`NEXT_PIT['A']`计算为`'B'`，表达式`OPPOSITE_PIT['A']`计算为`'G'`。注意代码是如何使用这些字典的。没有它们，我们的 Mancala 程序将需要一长串的`if`和`elif`语句来执行相同的游戏步骤。

```py
"""Mancala, by Al Sweigart email@protected #  1
The ancient seed-sowing game. #  2
This code is available at https://nostarch.com/big-book-small-python-programming #  3
Tags: large, board game, game, two-player""" #  4
 #  5
import sys #  6
 #  7
# A tuple of the player's pits: #  8
PLAYER_1_PITS = ('A', 'B', 'C', 'D', 'E', 'F') #  9
PLAYER_2_PITS = ('G', 'H', 'I', 'J', 'K', 'L') #  10
 #  11
# A dictionary whose keys are pits and values are opposite pit: #  12
OPPOSITE_PIT = {'A': 'G', 'B': 'H', 'C': 'I', 'D': 'J', 'E': 'K', #  13
                  'F': 'L', 'G': 'A', 'H': 'B', 'I': 'C', 'J': 'D', #  14
                  'K': 'E', 'L': 'F'} #  15
 #  16
# A dictionary whose keys are pits and values are the next pit in order: #  17
NEXT_PIT = {'A': 'B', 'B': 'C', 'C': 'D', 'D': 'E', 'E': 'F', 'F': '1', #  18
           '1': 'L', 'L': 'K', 'K': 'J', 'J': 'I', 'I': 'H', 'H': 'G', #  19
           'G': '2', '2': 'A'} #  20
 #  21
# Every pit label, in counterclockwise order starting with A: #  22
PIT_LABELS = 'ABCDEF1LKJIHG2' #  23
 #  24
# How many seeds are in each pit at the start of a new game: #  25
STARTING_NUMBER_OF_SEEDS = 4  # (!) Try changing this to 1 or 10. #  26
 #  27
 #  28
def main(): #  29
   print('''Mancala, by Al Sweigart email@protected #  30
 #  31
The ancient two-player, seed-sowing game. Grab the seeds from a pit on #  32
your side and place one in each following pit, going counterclockwise #  33
and skipping your opponent's store. If your last seed lands in an empty #  34
pit of yours, move the opposite pit's seeds into your store. The #  35
goal is to get the most seeds in your store on the side of the board. #  36
If the last placed seed is in your store, you get a free turn. #  37
 #  38
The game ends when all of one player's pits are empty. The other player #  39
claims the remaining seeds for their store, and the winner is the one #  40
with the most seeds. #  41
 #  42
More info at https://en.wikipedia.org/wiki/Mancala #  43
''') #  44
   input('Press Enter to begin...') #  45
 #  46
   gameBoard = getNewBoard() #  47
   playerTurn = '1'  # Player 1 goes first. #  48
 #  49
   while True:  # Run a player's turn. #  50
       # "Clear" the screen by printing many newlines, so the old #  51
       # board isn't visible anymore. #  52
       print('\n' * 60) #  53
       # Display board and get the player's move: #  54
       displayBoard(gameBoard) #  55
       playerMove = askForPlayerMove(playerTurn, gameBoard) #  56
 #  57
       # Carry out the player's move: #  58
       playerTurn = makeMove(gameBoard, playerTurn, playerMove) #  59
 #  60
       # Check if the game ended and a player has won: #  61
       winner = checkForWinner(gameBoard) #  62
       if winner == '1' or winner == '2': #  63
           displayBoard(gameBoard)  # Display the board one last time. #  64
           print('Player ' + winner + ' has won!') #  65
           sys.exit() #  66
       elif winner == 'tie': #  67
           displayBoard(gameBoard)  # Display the board one last time. #  68
           print('There is a tie!') #  69
           sys.exit() #  70
 #  71
 #  72
def getNewBoard(): #  73
   """Return a dictionary representing a Mancala board in the starting #  74
   state: 4 seeds in each pit and 0 in the stores.""" #  75
 #  76
   # Syntactic sugar - Use a shorter variable name: #  77
   s = STARTING_NUMBER_OF_SEEDS #  78
 #  79
   # Create the data structure for the board, with 0 seeds in the #  80
   # stores and the starting number of seeds in the pits: #  81
   return {'1': 0, '2': 0, 'A': s, 'B': s, 'C': s, 'D': s, 'E': s, #  82
           'F': s, 'G': s, 'H': s, 'I': s, 'J': s, 'K': s, 'L': s} #  83
 #  84
 #  85
def displayBoard(board): #  86
   """Displays the game board as ASCII-art based on the board #  87
   dictionary.""" #  88
 #  89
   seedAmounts = [] #  90
   # This 'GHIJKL21ABCDEF' string is the order of the pits left to #  91
   # right and top to bottom: #  92
   for pit in 'GHIJKL21ABCDEF': #  93
       numSeedsInThisPit = str(board[pit]).rjust(2) #  94
       seedAmounts.append(numSeedsInThisPit) #  95
 #  96
   print(""" #  97
+------+------+--<<<<<-Player 2----+------+------+------+ #  98
2      |G     |H     |I     |J     |K     |L     |      1 #  99
| {} | {} | {} | {} | {} | {} | # 100
S      |      |      |      |      |      |      |      S # 101
T {} +------+------+------+------+------+------+ {} T # 102
O      |A     |B     |C     |D     |E     |F     |      O # 103
R      | {} | {} | {} | {} | {} | {} |      R # 104
E      |      |      |      |      |      |      |      E # 105
+------+------+------+-Player 1->>>>>-----+------+------+ # 106
 # 107
""".format(*seedAmounts)) # 108
 # 109
 # 110
def askForPlayerMove(playerTurn, board): # 111
    """Asks the player which pit on their side of the board they # 112
    select to sow seeds from. Returns the uppercase letter label of the # 113
    selected pit as a string.""" # 114
 # 115
    while True:  # Keep asking the player until they enter a valid move. # 116
        # Ask the player to select a pit on their side: # 117
        if playerTurn == '1': # 118
            print('Player 1, choose move: A-F (or QUIT)') # 119
        elif playerTurn == '2': # 120
            print('Player 2, choose move: G-L (or QUIT)') # 121
        response = input('> ').upper().strip() # 122
 # 123
        # Check if the player wants to quit: # 124
        if response == 'QUIT': # 125
            print('Thanks for playing!') # 126
            sys.exit() # 127
 # 128
        # Make sure it is a valid pit to select: # 129
        if (playerTurn == '1' and response not in PLAYER_1_PITS) or ( # 130
            playerTurn == '2' and response not in PLAYER_2_PITS # 131
        ): # 132
            print('Please pick a letter on your side of the board.') # 133
            continue  # Ask player again for their move. # 134
        if board.get(response) == 0: # 135
            print('Please pick a non-empty pit.') # 136
            continue  # Ask player again for their move. # 137
        return response # 138
 # 139
 # 140
def makeMove(board, playerTurn, pit): # 141
    """Modify the board data structure so that the player 1 or 2 in # 142
    turn selected pit as their pit to sow seeds from. Returns either # 143
    '1' or '2' for whose turn it is next.""" # 144
 # 145
    seedsToSow = board[pit]  # Get number of seeds from selected pit. # 146
    board[pit] = 0  # Empty out the selected pit. # 147
 # 148
    while seedsToSow > 0:  # Continue sowing until we have no more seeds. # 149
        pit = NEXT_PIT[pit]  # Move on to the next pit. # 150
        if (playerTurn == '1' and pit == '2') or ( # 151
            playerTurn == '2' and pit == '1' # 152
        ): # 153
            continue  # Skip opponent's store. # 154
        board[pit] += 1 # 155
        seedsToSow -= 1 # 156
 # 157
    # If the last seed went into the player's store, they go again. # 158
    if (pit == playerTurn == '1') or (pit == playerTurn == '2'): # 159
        # The last seed landed in the player's store; take another turn. # 160
        return playerTurn # 161
 # 162
    # Check if last seed was in an empty pit; take opposite pit's seeds. # 163
    if playerTurn == '1' and pit in PLAYER_1_PITS and board[pit] == 1: # 164
        oppositePit = OPPOSITE_PIT[pit] # 165
        board['1'] += board[oppositePit] # 166
        board[oppositePit] = 0 # 167
    elif playerTurn == '2' and pit in PLAYER_2_PITS and board[pit] == 1: # 168
        oppositePit = OPPOSITE_PIT[pit] # 169
        board['2'] += board[oppositePit] # 170
        board[oppositePit] = 0 # 171
 # 172
    # Return the other player as the next player: # 173
    if playerTurn == '1': # 174
        return '2' # 175
    elif playerTurn == '2': # 176
        return '1' # 177
 # 178
 # 179
def checkForWinner(board): # 180
    """Looks at board and returns either '1' or '2' if there is a # 181
    winner or 'tie' or 'no winner' if there isn't. The game ends when a # 182
    player's pits are all empty; the other player claims the remaining # 183
    seeds for their store. The winner is whoever has the most seeds.""" # 184
 # 185
    player1Total = board['A'] + board['B'] + board['C'] # 186
    player1Total += board['D'] + board['E'] + board['F'] # 187
    player2Total = board['G'] + board['H'] + board['I'] # 188
    player2Total += board['J'] + board['K'] + board['L'] # 189
 # 190
    if player1Total == 0: # 191
        # Player 2 gets all the remaining seeds on their side: # 192
        board['2'] += player2Total # 193
        for pit in PLAYER_2_PITS: # 194
            board[pit] = 0  # Set all pits to 0. # 195
    elif player2Total == 0: # 196
        # Player 1 gets all the remaining seeds on their side: # 197
        board['1'] += player1Total # 198
        for pit in PLAYER_1_PITS: # 199
            board[pit] = 0  # Set all pits to 0. # 200
    else: # 201
        return 'no winner'  # No one has won yet. # 202
 # 203
    # Game is over, find player with largest score. # 204
    if board['1'] > board['2']: # 205
        return '1' # 206
    elif board['2'] > board['1']: # 207
        return '2' # 208
    else: # 209
        return 'tie' # 210
 # 211
 # 212
# If the program is run (instead of imported), run the game: # 213
if __name__ == '__main__': # 214
    main()  # 215
```

在输入源代码并运行几次之后，尝试对其进行实验性的修改。你也可以自己想办法做到以下几点:

*   换个板多点坑。
*   随机选择一个奖励坑，当最后一粒种子落在坑中时，让玩家进行另一轮游戏。
*   为四个玩家而不是两个玩家创建一个正方形的棋盘。

## 探索计划

试着找出下列问题的答案。尝试对代码进行一些修改，然后重新运行程序，看看这些修改有什么影响。

1.  如果把 175 行的`return '2'`改成`return '1'`会怎么样？
2.  如果把 208 行的`return '2'`改成`return '1'`会怎么样？
3.  如果把 125 行的`response == 'QUIT'`改成`response == 'quit'`会怎么样？
4.  如果把 147 行的`board[pit] = 0`改成`board[pit] = 1`会怎么样？
5.  如果把 53 行的`print('\n' * 60)`改成`print('\n' * 0)`会怎么样？
6.  如果把第 48 行的`playerTurn = '1'`改成`playerTurn = '2'`会怎么样？
7.  如果把 135 行的`board.get(response) == 0`改成`board.get(response) == -1`会怎么样？