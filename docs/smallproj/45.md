# 第 44 名迷宫赛跑者 2D

> 原文：<http://inventwithpython.com/bigbookpython/project44.html>

![](img/9d995d63aaead72cad01120081eb8f75.png)

这个二维迷宫向导向玩家展示了你在文本编辑器中创建的迷宫文件的俯视鸟瞰图，比如你用来编写`.py`文件的 IDE。使用 WASD 键，玩家可以分别向上、向左、向下和向右移动，将`@`符号导向由`X`字符标记的出口。

要创建一个迷宫文件，打开一个文本编辑器并创建以下模式。不要沿着顶部和左侧键入数字；它们仅供参考:

```py
 123456789
1#########
2#S# # # #
3##**#**#**#**#**#**##
4# # # # #
5##**#**#**#**#**#**##
6# # # # #
7##**#**#**#**#**#**##
8# # # #E#
9#########
```

#字符代表墙壁，`S`标记起点，`E`标记出口。粗体的#字符代表您可以移除以形成迷宫的墙壁。奇数列和奇数行的墙不要拆，迷宫的边界不要拆。完成后，将迷宫保存为`txt`(文本)文件。它可能看起来像这样:

```py
#########
#S    # #
# ### # #
# #   # #
# ##### #
#   #   #
### # # #
#     #E#
#########
```

当然，这是一个简单的迷宫。您可以创建任意大小的迷宫文件，只要它们的行数和列数为奇数。但是，请确保它仍然适合屏幕！你也可以从[`invpy.com/mazes`](https://invpy.com/mazes/)下载迷宫文件。

## 行动中的计划

当您运行 `mazerunner2d.py` 时，输出将如下所示:

```py
Maze Runner 2D, by Al Sweigart email@protected

(Maze files are generated by mazemakerrec.py)
Enter the filename of the maze (or LIST or QUIT):
> maze65x11s1.txt
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
░@░     ░       ░               ░                       ░   ░   ░
░ ░░░░░ ░ ░░░ ░ ░ ░░░░░░░ ░░░░░ ░░░░░░░░░░░░░░░░░░░░░ ░░░ ░ ░ ░ ░
░ ░   ░     ░ ░ ░   ░   ░     ░   ░           ░     ░   ░ ░   ░ ░
░ ░ ░ ░░░░░ ░ ░ ░░░░░ ░ ░░░░░ ░░░ ░ ░░░░░░░░░ ░ ░░░ ░░░ ░ ░░░░░ ░
░   ░     ░ ░ ░   ░   ░       ░ ░   ░       ░ ░ ░ ░   ░   ░     ░
░░░░░░░░░ ░░░ ░░░ ░ ░░░░░░░░░░░ ░░░░░ ░ ░░░░░ ░ ░ ░░░ ░░░░░ ░░░░░
░ ░     ░ ░   ░ ░ ░ ░           ░     ░       ░ ░     ░   ░     ░
░ ░ ░ ░░░ ░ ░░░ ░ ░ ░ ░░░░░░░░░░░ ░░░░░░░░░░░░░ ░ ░░░░░ ░ ░░░░░ ░
░   ░       ░       ░                           ░       ░      X░
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
                           W
Enter direction, or QUIT: ASD
`--snip--`
```

## 它是如何工作的

该程序从一个文本文件中加载迷宫墙壁的数据，并将其加载到存储在`maze`变量中的字典中。这个字典有用于键的`(x, y)`元组和用于值的`WALL`、`EMPTY`、`START`或`EXIT`常量中的字符串。项目 45“迷宫赛跑者 3D”使用了类似的迷宫字典表示。这两个项目的区别在于在屏幕上呈现迷宫的代码。由于迷宫赛跑者 2D 更简单，我推荐在进入迷宫赛跑者 3D 之前先熟悉这个程序。

```py
"""Maze Runner 2D, by Al Sweigart email@protected
Move around a maze and try to escape. Maze files are generated by
mazemakerrec.py.
This code is available at https://nostarch.com/big-book-small-python-programming
Tags: large, game, maze"""

import sys, os

# Maze file constants:
WALL = '#'
EMPTY = ' '
START = 'S'
EXIT = 'E'

PLAYER = '@'  # (!) Try changing this to '+' or 'o'.
BLOCK = chr(9617)  # Character 9617 is '░'


def displayMaze(maze):
   # Display the maze:
   for y in range(HEIGHT):
       for x in range(WIDTH):
           if (x, y) == (playerx, playery):
               print(PLAYER, end='')
           elif (x, y) == (exitx, exity):
               print('X', end='')
           elif maze[(x, y)] == WALL:
               print(BLOCK, end='')
           else:
               print(maze[(x, y)], end='')
       print()  # Print a newline after printing the row.


print('''Maze Runner 2D, by Al Sweigart email@protected

(Maze files are generated by mazemakerrec.py)''')

# Get the maze file's filename from the user:
while True:
   print('Enter the filename of the maze (or LIST or QUIT):')
   filename = input('> ')

   # List all the maze files in the current folder:
   if filename.upper() == 'LIST':
       print('Maze files found in', os.getcwd())
       for fileInCurrentFolder in os.listdir():
           if (fileInCurrentFolder.startswith('maze') and
           fileInCurrentFolder.endswith('.txt')):
               print('  ', fileInCurrentFolder)
       continue

   if filename.upper() == 'QUIT':
       sys.exit()

   if os.path.exists(filename):
       break
   print('There is no file named', filename)

# Load the maze from a file:
mazeFile = open(filename)
maze = {}
lines = mazeFile.readlines()
playerx = None
playery = None
exitx = None
exity = None
y = 0
for line in lines:
   WIDTH = len(line.rstrip())
   for x, character in enumerate(line.rstrip()):
       assert character in (WALL, EMPTY, START, EXIT), 'Invalid character at column {}, line {}'.format(x + 1, y + 1)
       if character in (WALL, EMPTY):
           maze[(x, y)] = character
       elif character == START:
           playerx, playery = x, y
           maze[(x, y)] = EMPTY
       elif character == EXIT:
           exitx, exity = x, y
           maze[(x, y)] = EMPTY
   y += 1
HEIGHT = y

assert playerx != None and playery != None, 'No start in maze file.'
assert exitx != None and exity != None, 'No exit in maze file.'

while True:  # Main game loop.
   displayMaze(maze)

   while True:  # Get user move.
       print('                           W')
       print('Enter direction, or QUIT: ASD')
       move = input('> ').upper()

       if move == 'QUIT':
           print('Thanks for playing!')
           sys.exit()

       if move not in ['W', 'A', 'S', 'D']:
           print('Invalid direction. Enter one of W, A, S, or D.')
            continue

        # Check if the player can move in that direction:
        if move == 'W' and maze[(playerx, playery - 1)] == EMPTY:
            break
        elif move == 'S' and maze[(playerx, playery + 1)] == EMPTY:
            break
        elif move == 'A' and maze[(playerx - 1, playery)] == EMPTY:
            break
        elif move == 'D' and maze[(playerx + 1, playery)] == EMPTY:
            break

        print('You cannot move in that direction.')

    # Keep moving in this direction until you encounter a branch point.
    if move == 'W':
        while True:
            playery -= 1
            if (playerx, playery) == (exitx, exity):
                break
            if maze[(playerx, playery - 1)] == WALL:
                break  # Break if we've hit a wall.
            if (maze[(playerx - 1, playery)] == EMPTY
                or maze[(playerx + 1, playery)] == EMPTY):
                break  # Break if we've reached a branch point.
    elif move == 'S':
        while True:
            playery += 1
            if (playerx, playery) == (exitx, exity):
                break
            if maze[(playerx, playery + 1)] == WALL:
                break  # Break if we've hit a wall.
            if (maze[(playerx - 1, playery)] == EMPTY
                or maze[(playerx + 1, playery)] == EMPTY):
                break  # Break if we've reached a branch point.
    elif move == 'A':
        while True:
            playerx -= 1
            if (playerx, playery) == (exitx, exity):
                break
            if maze[(playerx - 1, playery)] == WALL:
                break  # Break if we've hit a wall.
            if (maze[(playerx, playery - 1)] == EMPTY
                or maze[(playerx, playery + 1)] == EMPTY):
                break  # Break if we've reached a branch point.
    elif move == 'D':
        while True:
            playerx += 1
            if (playerx, playery) == (exitx, exity):
                break
            if maze[(playerx + 1, playery)] == WALL:
                break  # Break if we've hit a wall.
            if (maze[(playerx, playery - 1)] == EMPTY
                or maze[(playerx, playery + 1)] == EMPTY):
                break  # Break if we've reached a branch point.

    if (playerx, playery) == (exitx, exity):
        displayMaze(maze)
        print('You have reached the exit! Good job!')
        print('Thanks for playing!')
        sys.exit() 
```

## 探索计划

试着找出下列问题的答案。尝试对代码进行一些修改，然后重新运行程序，看看这些修改有什么影响。

1.  如果将第 74 行的`character == START`改为`character == EXIT`，会得到什么错误信息？
2.  如果把 105 行的`playery + 1`改成`playery – 1`会怎么样？
3.  如果把 156 行的`(exitx, exity)`改成`(None, None)`会怎么样？
4.  如果将第 89 行的`while True:`改为`while False:`，会得到什么错误信息？
5.  如果把 104 行的`break`改成`continue`会怎么样？
6.  如果将第 121 行的`break`改为`continue`，会得到什么错误信息？