# #23 蚀刻抽屉

> 原文：<http://inventwithpython.com/bigbookpython/project23.html>

![](img/9d995d63aaead72cad01120081eb8f75.png)

当您使用 WASD 键在屏幕上移动笔尖时，蚀刻抽屉通过描绘一条连续的线来形成一幅图片，就像蚀刻素描玩具一样。让你艺术的一面爆发出来，看看你能创造出什么形象！这个程序还可以让你把你的绘图保存到一个文本文件中，这样你以后就可以把它们打印出来。此外，你可以将其他图形的 WASD 运动复制粘贴到这个程序中，比如源代码第 6 到 14 行中的希尔伯特曲线分形的 WASD 命令。

## 行动中的计划

当你运行 `etchingdrawer.py` 时，输出将看起来像[图 23-1](#calibre_link-338) 。

![f23001](img/356f320ea06da16799f6e0d35deffb4b.png)

:在蚀刻抽屉程序中绘制的图

## 它是如何工作的

与项目 17“骰子数学”一样，这个程序使用存储在名为`canvas`的变量中的字典来记录绘图的线条。关键字是`(x, y)`元组，值是表示要在屏幕上的 x，y 坐标处绘制的线形的字符串。附录 b 给出了可以在 Python 程序中使用的 Unicode 字符的完整列表。

第 126 行有一个对`open()`的函数调用，它传递了一个`encoding='utf-8'`参数。原因超出了本书的范围，但这是 Windows 将行字符写入文本文件所必需的。

```py
"""Etching Drawer, by Al Sweigart email@protected #  1
An art program that draws a continuous line around the screen using the #  2
WASD keys. Inspired by Etch A Sketch toys. #  3
 #  4
For example, you can draw Hilbert Curve fractal with: #  5
SDWDDSASDSAAWASSDSASSDWDSDWWAWDDDSASSDWDSDWWAWDWWASAAWDWAWDDSDW #  6
 #  7
Or an even larger Hilbert Curve fractal with: #  8
DDSAASSDDWDDSDDWWAAWDDDDSDDWDDDDSAASDDSAAAAWAASSSDDWDDDDSAASDDSAAAAWA #  9
ASAAAAWDDWWAASAAWAASSDDSAASSDDWDDDDSAASDDSAAAAWAASSDDSAASSDDWDDSDDWWA #  10
AWDDDDDDSAASSDDWDDSDDWWAAWDDWWAASAAAAWDDWAAWDDDDSDDWDDSDDWDDDDSAASDDS #  11
AAAAWAASSDDSAASSDDWDDSDDWWAAWDDDDDDSAASSDDWDDSDDWWAAWDDWWAASAAAAWDDWA #  12
AWDDDDSDDWWAAWDDWWAASAAWAASSDDSAAAAWAASAAAAWDDWAAWDDDDSDDWWWAASAAAAWD #  13
DWAAWDDDDSDDWDDDDSAASSDDWDDSDDWWAAWDD #  14
 #  15
This code is available at https://nostarch.com/big-book-small-python-programming #  16
Tags: large, artistic""" #  17
 #  18
import shutil, sys #  19
 #  20
# Set up the constants for line characters: #  21
UP_DOWN_CHAR         = chr(9474)  # Character 9474 is '│' #  22
LEFT_RIGHT_CHAR      = chr(9472)  # Character 9472 is '─' #  23
DOWN_RIGHT_CHAR      = chr(9484)  # Character 9484 is '┌' #  24
DOWN_LEFT_CHAR       = chr(9488)  # Character 9488 is '┐' #  25
UP_RIGHT_CHAR        = chr(9492)  # Character 9492 is '└' #  26
UP_LEFT_CHAR         = chr(9496)  # Character 9496 is '┘' #  27
UP_DOWN_RIGHT_CHAR   = chr(9500)  # Character 9500 is '├' #  28
UP_DOWN_LEFT_CHAR    = chr(9508)  # Character 9508 is '┤' #  29
DOWN_LEFT_RIGHT_CHAR = chr(9516)  # Character 9516 is '┬' #  30
UP_LEFT_RIGHT_CHAR   = chr(9524)  # Character 9524 is '┴' #  31
CROSS_CHAR           = chr(9532)  # Character 9532 is '┼' #  32
# A list of chr() codes is at https://inventwithpython.com/chr #  33
 #  34
# Get the size of the terminal window: #  35
CANVAS_WIDTH, CANVAS_HEIGHT = shutil.get_terminal_size() #  36
# We can't print to the last column on Windows without it adding a #  37
# newline automatically, so reduce the width by one: #  38
CANVAS_WIDTH -= 1 #  39
# Leave room at the bottom few rows for the command info lines. #  40
CANVAS_HEIGHT -= 5 #  41
 #  42
"""The keys for canvas will be (x, y) integer tuples for the coordinate, #  43
and the value is a set of letters W, A, S, D that tell what kind of line #  44
should be drawn.""" #  45
canvas = {} #  46
cursorX = 0 #  47
cursorY = 0 #  48
 #  49
 #  50
def getCanvasString(canvasData, cx, cy): #  51
   """Returns a multiline string of the line drawn in canvasData.""" #  52
   canvasStr = '' #  53
 #  54
   """canvasData is a dictionary with (x, y) tuple keys and values that #  55
   are sets of 'W', 'A', 'S', and/or 'D' strings to show which #  56
   directions the lines are drawn at each xy point.""" #  57
   for rowNum in range(CANVAS_HEIGHT): #  58
       for columnNum in range(CANVAS_WIDTH): #  59
           if columnNum == cx and rowNum == cy: #  60
               canvasStr += '#' #  61
               continue #  62
 #  63
           # Add the line character for this point to canvasStr. #  64
           cell = canvasData.get((columnNum, rowNum)) #  65
           if cell in (set(['W', 'S']), set(['W']), set(['S'])): #  66
               canvasStr += UP_DOWN_CHAR #  67
           elif cell in (set(['A', 'D']), set(['A']), set(['D'])): #  68
               canvasStr += LEFT_RIGHT_CHAR #  69
           elif cell == set(['S', 'D']): #  70
               canvasStr += DOWN_RIGHT_CHAR #  71
           elif cell == set(['A', 'S']): #  72
               canvasStr += DOWN_LEFT_CHAR #  73
           elif cell == set(['W', 'D']): #  74
               canvasStr += UP_RIGHT_CHAR #  75
           elif cell == set(['W', 'A']): #  76
               canvasStr += UP_LEFT_CHAR #  77
           elif cell == set(['W', 'S', 'D']): #  78
               canvasStr += UP_DOWN_RIGHT_CHAR #  79
           elif cell == set(['W', 'S', 'A']): #  80
               canvasStr += UP_DOWN_LEFT_CHAR #  81
           elif cell == set(['A', 'S', 'D']): #  82
               canvasStr += DOWN_LEFT_RIGHT_CHAR #  83
           elif cell == set(['W', 'A', 'D']): #  84
               canvasStr += UP_LEFT_RIGHT_CHAR #  85
           elif cell == set(['W', 'A', 'S', 'D']): #  86
               canvasStr += CROSS_CHAR #  87
           elif cell == None: #  88
               canvasStr += ' ' #  89
       canvasStr += '\n'  # Add a newline at the end of each row. #  90
   return canvasStr #  91
 #  92
 #  93
moves = [] #  94
while True:  # Main program loop. #  95
   # Draw the lines based on the data in canvas: #  96
   print(getCanvasString(canvas, cursorX, cursorY)) #  97
 #  98
   print('WASD keys to move, H for help, C to clear, ' #  99
        + 'F to save, or QUIT.') # 100
    response = input('> ').upper() # 101
 # 102
    if response == 'QUIT': # 103
        print('Thanks for playing!') # 104
        sys.exit()  # Quit the program. # 105
    elif response == 'H': # 106
        print('Enter W, A, S, and D characters to move the cursor and') # 107
        print('draw a line behind it as it moves. For example, ddd') # 108
        print('draws a line going right and sssdddwwwaaa draws a box.') # 109
        print() # 110
        print('You can save your drawing to a text file by entering F.') # 111
        input('Press Enter to return to the program...') # 112
        continue # 113
    elif response == 'C': # 114
        canvas = {}  # Erase the canvas data. # 115
        moves.append('C')  # Record this move. # 116
    elif response == 'F': # 117
        # Save the canvas string to a text file: # 118
        try: # 119
            print('Enter filename to save to:') # 120
            filename = input('> ') # 121
 # 122
            # Make sure the filename ends with .txt: # 123
            if not filename.endswith('.txt'): # 124
                filename += '.txt' # 125
            with open(filename, 'w', encoding='utf-8') as file: # 126
                file.write(''.join(moves) + '\n') # 127
                file.write(getCanvasString(canvas, None, None)) # 128
        except: # 129
            print('ERROR: Could not save file.') # 130
 # 131
    for command in response: # 132
        if command not in ('W', 'A', 'S', 'D'): # 133
            continue  # Ignore this letter and continue to the next one. # 134
        moves.append(command)  # Record this move. # 135
 # 136
        # The first line we add needs to form a full line: # 137
        if canvas == {}: # 138
            if command in ('W', 'S'): # 139
                # Make the first line a horizontal one: # 140
                canvas[(cursorX, cursorY)] = set(['W', 'S']) # 141
            elif command in ('A', 'D'): # 142
                # Make the first line a vertical one: # 143
                canvas[(cursorX, cursorY)] = set(['A', 'D']) # 144
 # 145
        # Update x and y: # 146
        if command == 'W' and cursorY > 0: # 147
            canvas[(cursorX, cursorY)].add(command) # 148
            cursorY = cursorY - 1 # 149
        elif command == 'S' and cursorY < CANVAS_HEIGHT - 1: # 150
            canvas[(cursorX, cursorY)].add(command) # 151
            cursorY = cursorY + 1 # 152
        elif command == 'A' and cursorX > 0: # 153
            canvas[(cursorX, cursorY)].add(command) # 154
            cursorX = cursorX - 1 # 155
        elif command == 'D' and cursorX < CANVAS_WIDTH - 1: # 156
            canvas[(cursorX, cursorY)].add(command) # 157
            cursorX = cursorX + 1 # 158
        else: # 159
            # If the cursor doesn't move because it would have moved off # 160
            # the edge of the canvas, then don't change the set at # 161
            # canvas[(cursorX, cursorY)]. # 162
            continue # 163
 # 164
        # If there's no set for (cursorX, cursorY), add an empty set: # 165
        if (cursorX, cursorY) not in canvas: # 166
            canvas[(cursorX, cursorY)] = set() # 167
 # 168
        # Add the direction string to this xy point's set: # 169
        if command == 'W': # 170
            canvas[(cursorX, cursorY)].add('S') # 171
        elif command == 'S': # 172
            canvas[(cursorX, cursorY)].add('W') # 173
        elif command == 'A': # 174
            canvas[(cursorX, cursorY)].add('D') # 175
        elif command == 'D': # 176
            canvas[(cursorX, cursorY)].add('A')  # 177
```

## 探索计划

试着找出下列问题的答案。尝试对代码进行一些修改，然后重新运行程序，看看这些修改有什么影响。

1.  如果把 101 行的`response = input('> ').upper()`改成`response = input('> ')`会怎么样？
2.  如果把第 61 行的`canvasStr += '#'`改成`canvasStr += '@'`会怎么样？
3.  如果把第 89 行的`canvasStr += ' '`改成`canvasStr += '.'`会怎么样？
4.  如果把 94 行的`moves = []`改成`moves = list('SDWDDSASDSAAWASSDSAS')`会怎么样？