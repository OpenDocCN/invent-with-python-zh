# #63 乌尔皇家游戏

> 原文：<http://inventwithpython.com/bigbookpython/project63.html>

![](img/9d995d63aaead72cad01120081eb8f75.png)

乌尔的皇家游戏是一个来自美索不达米亚的有 5000 年历史的游戏。考古学家在 1922 年至 1934 年间的挖掘过程中，在现代伊拉克南部的乌尔皇家墓地重新发现了这款游戏。这些规则是根据游戏棋盘(如图 63-1 所示)和一块巴比伦泥板重建的，它们类似于 Parcheesi。你需要运气和技巧才能赢。

![f63001](img/7acea4adc528e4cdfe27d72ef840b2ed.png)

图 63-1 :在乌尔皇家墓地发现的五块游戏板之一

两名玩家每人从家中的七个代币开始，第一个将所有七个代币移动到目标位置的玩家获胜。玩家轮流掷出四个骰子。这些骰子是称为四面体的四角金字塔形状。每个骰子都有两个标记点，这使得骰子有标记或无标记的机会均等。我们的游戏用硬币代替骰子，硬币的头部作为标记点。玩家可以为出现的每一个标记点移动一格代币。这意味着他们可以在 0 到 4 个空格之间移动一个令牌，尽管他们最有可能掷出两个空格。

代币沿着图 63-2 中[所示的路径行进。一个空间上一次只能存在一个令牌。如果一个代币在共享中间路径上落在对手的代币上，对手的代币会被送回家。如果一个代币落在中间的花方格上，它就不会被落在上面。如果一个代币落在其他四个花牌中的任何一个上，玩家可以再掷一次。我们的游戏将用字母 `X` 和 `O` 来代表代币。](#calibre_link-350)

![f63002](img/090375ba5d7c9fc00f05d83315f6d46e.png)

图 63-2 :每个玩家的令牌从他们的家到他们的目标的路径

在`www.youtube.com/watch?v=WZskjLq040I`可以找到优图伯·汤姆·斯科特和大英博物馆馆长欧文·芬克尔讨论乌尔王族游戏的视频。

## 行动中的计划

当您运行 `royalgameofur.py` 时，输出将如下所示:

```py
The Royal Game of Ur, by Al Sweigart
`--snip--`
                   XXXXXXX           .......
                   Home              Goal
                     v                 ^
+-----+-----+-----+--v--+           +--^--+-----+
|*****|     |     |     |           |*****|     |
|*   *<     <     <     |           |*   *<     |
|****h|    g|    f|    e|           |****t|    s|
+--v--+-----+-----+-----+-----+-----+-----+--^--+
|     |     |     |*****|     |     |     |     |
|     >     >     >*   *>     >     >     >     |
|    i|    j|    k|****l|    m|    n|    o|    p|
+--^--+-----+-----+-----+-----+-----+-----+--v--+
|*****|     |     |     |           |*****|     |
|*   *<     <     <     |           |*   *<     |
|****d|    c|    b|    a|           |****r|    q|
+-----+-----+-----+--^--+           +--v--+-----+
                     ^                 v
                   Home              Goal
                   OOOOOOO           .......

It is O's turn. Press Enter to flip...
Flips: H-H-H-H  Select token to move 4 spaces: home quit
> home
O landed on a flower space and gets to go again.
Press Enter to continue...
`--snip--`
```

## 它是如何工作的

就像项目 43“曼卡拉”一样，ASCII 艺术游戏棋盘上的空格用字母 `a` 到 `t` 标注。掷骰子后，玩家可以选择一个包含其代币的空间来移动代币，或者他们可以选择`home`开始将代币从家中移到棋盘上。该程序将棋盘表示为一个字典，其中键为`'a'`到`'t'`，值为`'X'`和`'O'`用于标记(或`' '`用于空格)。

此外，这个字典有关键字`'x_home'`、`'o_home'`、`'x_goal'`和`'o_goal'`，这些关键字的值是七个字符的字符串，表示家庭和目标有多满。这些字符串中的`'X'`或`'O'`字符代表主场或球门的代币，`'.'`代表空位置。`displayBoard()`函数在屏幕上显示这七个字符串。

```py
"""The Royal Game of Ur, by Al Sweigart email@protected #  1
A 5,000 year old board game from Mesopotamia. Two players knock each #  2
other back as they race for the goal. #  3
More info https://en.wikipedia.org/wiki/Royal_Game_of_Ur #  4
This code is available at https://nostarch.com/big-book-small-python-programming #  5
Tags: large, board game, game, two-player #  6
""" #  7
 #  8
import random, sys #  9
 #  10
X_PLAYER = 'X' #  11
O_PLAYER = 'O' #  12
EMPTY = ' ' #  13
 #  14
# Set up constants for the space labels: #  15
X_HOME = 'x_home' #  16
O_HOME = 'o_home' #  17
X_GOAL = 'x_goal' #  18
O_GOAL = 'o_goal' #  19
 #  20
# The spaces in left to right, top to bottom order: #  21
ALL_SPACES = 'hgfetsijklmnopdcbarq' #  22
X_TRACK = 'HefghijklmnopstG'  # (H stands for Home, G stands for Goal.) #  23
O_TRACK = 'HabcdijklmnopqrG' #  24
 #  25
FLOWER_SPACES = ('h', 't', 'l', 'd', 'r') #  26
 #  27
BOARD_TEMPLATE = """ #  28
{}  {} 30\.                   Home              Goal #  29
                    v                 ^ #  31
+-----+-----+-----+--v--+           +--^--+-----+ #  32
|*****|     |     |     |           |*****|     | #  33
|* {} *< {} < {} < {} |           |* {} *< {} | #  34
|****h|    g|    f|    e|           |****t|    s| #  35
+--v--+-----+-----+-----+-----+-----+-----+--^--+ #  36
|     |     |     |*****|     |     |     |     | #  37
| {} > {} > {} >* {} *> {} > {} > {} > {} | #  38
|    i|    j|    k|****l|    m|    n|    o|    p| #  39
+--^--+-----+-----+-----+-----+-----+-----+--v--+ #  40
|*****|     |     |     |           |*****|     | #  41
|* {} *< {} < {} < {} |           |* {} *< {} | #  42
|****d|    c|    b|    a|           |****r|    q| #  43
+-----+-----+-----+--^--+           +--v--+-----+ #  44
                    ^                 v #  45
                  Home              Goal #  46
{}  {} 48\. """ #  47
 #  49
 #  50
def main(): #  51
   print('''The Royal Game of Ur, by Al Sweigart #  52
 #  53
This is a 5,000 year old game. Two players must move their tokens #  54
from their home to their goal. On your turn you flip four coins and can #  55
move one token a number of spaces equal to the heads you got. #  56
 #  57
Ur is a racing game; the first player to move all seven of their tokens #  58
to their goal wins. To do this, tokens must travel from their home to #  59
their goal: #  60
 #  61
           X Home      X Goal #  62
             v           ^ #  63
+---+---+---+-v-+       +-^-+---+ #  64
|v<<<<<<<<<<<<< |       | ^<|<< | #  65
|v  |   |   |   |       |   | ^ | #  66
+v--+---+---+---+---+---+---+-^-+ #  67
|>>>>>>>>>>>>>>>>>>>>>>>>>>>>>^ | #  68
|>>>>>>>>>>>>>>>>>>>>>>>>>>>>>v | #  69
+^--+---+---+---+---+---+---+-v-+ #  70
|^  |   |   |   |       |   | v | #  71
|^<<<<<<<<<<<<< |       | v<<<< | #  72
+---+---+---+-^-+       +-v-+---+ #  73
             ^           v #  74
           O Home      O Goal #  75
 #  76
If you land on an opponent's token in the middle track, it gets sent #  77
back home. The **flower** spaces let you take another turn. Tokens in #  78
the middle flower space are safe and cannot be landed on.''') #  79
   input('Press Enter to begin...') #  80
 #  81
   gameBoard = getNewBoard() #  82
   turn = O_PLAYER #  83
   while True:  # Main game loop. #  84
       # Set up some variables for this turn: #  85
       if turn == X_PLAYER: #  86
           opponent = O_PLAYER #  87
           home = X_HOME #  88
           track = X_TRACK #  89
           goal = X_GOAL #  90
           opponentHome = O_HOME #  91
       elif turn == O_PLAYER: #  92
           opponent = X_PLAYER #  93
           home = O_HOME #  94
           track = O_TRACK #  95
           goal = O_GOAL #  96
           opponentHome = X_HOME #  97
 #  98
       displayBoard(gameBoard) #  99
 # 100
        input('It is ' + turn + '\'s turn. Press Enter to flip...') # 101
 # 102
        flipTally = 0 # 103
        print('Flips: ', end='') # 104
        for i in range(4):  # Flip 4 coins. # 105
            result = random.randint(0, 1) # 106
            if result == 0: # 107
                print('T', end='')  # Tails. # 108
            else: # 109
                print('H', end='')  # Heads. # 110
            if i != 3: # 111
                print('-', end='')  # Print separator. # 112
            flipTally += result # 113
        print('  ', end='') # 114
 # 115
        if flipTally == 0: # 116
            input('You lose a turn. Press Enter to continue...') # 117
            turn = opponent  # Swap turns to the other player. # 118
            continue # 119
 # 120
        # Ask the player for their move: # 121
        validMoves = getValidMoves(gameBoard, turn, flipTally) # 122
 # 123
        if validMoves == []: # 124
            print('There are no possible moves, so you lose a turn.') # 125
            input('Press Enter to continue...') # 126
            turn = opponent  # Swap turns to the other player. # 127
            continue # 128
 # 129
        while True: # 130
            print('Select move', flipTally, 'spaces: ', end='') # 131
            print(' '.join(validMoves) + ' quit') # 132
            move = input('> ').lower() # 133
 # 134
            if move == 'quit': # 135
                print('Thanks for playing!') # 136
                sys.exit() # 137
            if move in validMoves: # 138
                break  # Exit the loop when a valid move is selected. # 139
 # 140
            print('That is not a valid move.') # 141
 # 142
        # Perform the selected move on the board: # 143
        if move == 'home': # 144
            # Subtract tokens at home if moving from home: # 145
            gameBoard[home] -= 1 # 146
            nextTrackSpaceIndex = flipTally # 147
        else: # 148
            gameBoard[move] = EMPTY  # Set the "from" space to empty. # 149
            nextTrackSpaceIndex = track.index(move) + flipTally # 150
 # 151
        movingOntoGoal = nextTrackSpaceIndex == len(track) - 1 # 152
        if movingOntoGoal: # 153
            gameBoard[goal] += 1 # 154
            # Check if the player has won: # 155
            if gameBoard[goal] == 7: # 156
                displayBoard(gameBoard) # 157
                print(turn, 'has won the game!') # 158
                print('Thanks for playing!') # 159
                sys.exit() # 160
        else: # 161
            nextBoardSpace = track[nextTrackSpaceIndex] # 162
            # Check if the opponent has a tile there: # 163
            if gameBoard[nextBoardSpace] == opponent: # 164
                gameBoard[opponentHome] += 1 # 165
 # 166
            # Set the "to" space to the player's token: # 167
            gameBoard[nextBoardSpace] = turn # 168
 # 169
        # Check if the player landed on a flower space and can go again: # 170
        if nextBoardSpace in FLOWER_SPACES: # 171
            print(turn, 'landed on a flower space and goes again.') # 172
            input('Press Enter to continue...') # 173
        else: # 174
            turn = opponent  # Swap turns to the other player. # 175
 # 176
def getNewBoard(): # 177
    """ # 178
    Returns a dictionary that represents the state of the board. The # 179
    keys are strings of the space labels, the values are X_PLAYER, # 180
    O_PLAYER, or EMPTY. There are also counters for how many tokens are # 181
    at the home and goal of both players. # 182
    """ # 183
    board = {X_HOME: 7, X_GOAL: 0, O_HOME: 7, O_GOAL: 0} # 184
    # Set each space as empty to start: # 185
    for spaceLabel in ALL_SPACES: # 186
        board[spaceLabel] = EMPTY # 187
    return board # 188
 # 189
 # 190
def displayBoard(board): # 191
    """Display the board on the screen.""" # 192
    # "Clear" the screen by printing many newlines, so the old # 193
    # board isn't visible anymore. # 194
    print('\n' * 60) # 195
 # 196
    xHomeTokens = ('X' * board[X_HOME]).ljust(7, '.') # 197
    xGoalTokens = ('X' * board[X_GOAL]).ljust(7, '.') # 198
    oHomeTokens = ('O' * board[O_HOME]).ljust(7, '.') # 199
    oGoalTokens = ('O' * board[O_GOAL]).ljust(7, '.') # 200
 # 201
    # Add the strings that should populate BOARD_TEMPLATE in order, # 202
    # going from left to right, top to bottom. # 203
    spaces = [] # 204
    spaces.append(xHomeTokens) # 205
    spaces.append(xGoalTokens) # 206
    for spaceLabel in ALL_SPACES: # 207
        spaces.append(board[spaceLabel]) # 208
    spaces.append(oHomeTokens) # 209
    spaces.append(oGoalTokens) # 210
 # 211
    print(BOARD_TEMPLATE.format(*spaces)) # 212
 # 213
 # 214
def getValidMoves(board, player, flipTally): # 215
    validMoves = []  # Contains the spaces with tokens that can move. # 216
    if player == X_PLAYER: # 217
        opponent = O_PLAYER # 218
        track = X_TRACK # 219
        home = X_HOME # 220
    elif player == O_PLAYER: # 221
        opponent = X_PLAYER # 222
        track = O_TRACK # 223
        home = O_HOME # 224
 # 225
    # Check if the player can move a token from home: # 226
    if board[home] > 0 and board[track[flipTally]] == EMPTY: # 227
        validMoves.append('home') # 228
 # 229
    # Check which spaces have a token the player can move: # 230
    for trackSpaceIndex, space in enumerate(track): # 231
        if space == 'H' or space == 'G' or board[space] != player: # 232
            continue # 233
        nextTrackSpaceIndex = trackSpaceIndex + flipTally # 234
        if nextTrackSpaceIndex >= len(track): # 235
            # You must flip an exact number of moves onto the goal, # 236
            # otherwise you can't move on the goal. # 237
            continue # 238
        else: # 239
            nextBoardSpaceKey = track[nextTrackSpaceIndex] # 240
            if nextBoardSpaceKey == 'G': # 241
                # This token can move off the board: # 242
                validMoves.append(space) # 243
                continue # 244
        if board[nextBoardSpaceKey] in (EMPTY, opponent): # 245
            # If the next space is the protected middle space, you # 246
            # can only move there if it is empty: # 247
            if nextBoardSpaceKey == 'l' and board['l'] == opponent: # 248
                continue  # Skip this move, the space is protected. # 249
            validMoves.append(space) # 250
 # 251
    return validMoves # 252
 # 253
 # 254
if __name__ == '__main__': # 255
    main()  # 256
```

## 探索计划

试着找出下列问题的答案。尝试对代码进行一些修改，然后重新运行程序，看看这些修改有什么影响。

1.  如果把 152 行的`nextTrackSpaceIndex == len(track) - 1`改成`nextTrackSpaceIndex == 1`会怎么样？
2.  如果把 106 行的`result = random.randint(0, 1)`改成`result = 1`会怎么样？
3.  如果把 184 行的`board = {X_HOME: 7, X_GOAL: 0, O_HOME: 7, O_GOAL: 0}`改成`board = {}`会导致什么错误？