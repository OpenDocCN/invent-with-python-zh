# #30 四连冠

> 原文：<http://inventwithpython.com/bigbookpython/project30.html>

![](img/9d995d63aaead72cad01120081eb8f75.png)

在这款经典的双人掷瓷砖棋盘游戏中，你必须设法让你的四块瓷砖水平、垂直或对角排成一行，同时防止你的对手做同样的事情。这个程序类似于 Connect Four。

## 行动中的计划

当您运行 `fourinarow.py` 时，输出将如下所示:

```py
Four in a Row, by Al Sweigart email@protected
`--snip--`
     1234567
    +-------+
    |.......|
    |.......|
    |.......|
    |.......|
    |.......|
    |.......|
    +-------+
Player X, enter a column or QUIT:
> 3

     1234567
    +-------+
    |.......|
    |.......|
    |.......|
    |.......|
    |.......|
    |..X....|
    +-------+
Player O, enter a column or QUIT:
> 5
`--snip--`
Player O, enter a column or QUIT:
> 4

     1234567
    +-------+
    |.......|
    |.......|
    |XXX.XO.|
    |OOOOXO.|
    |OOOXOX.|
    |OXXXOXX|
    +-------+
Player O has won!
```

## 它是如何工作的

本书中的棋盘游戏项目遵循类似的程序结构。通常有一个字典或列表来表示电路板的状态，一个`getNewBoard()`函数返回电路板的数据结构，一个`displayBoard()`函数在屏幕上呈现电路板的数据结构，等等。你可以查看本书中带有*桌游*标签的其他项目，并相互比较，尤其是当你想创建自己的原创桌游程序时。

```py
"""Four in a Row, by Al Sweigart email@protected #  1
A tile-dropping game to get four in a row, similar to Connect Four. #  2
This code is available at https://nostarch.com/big-book-small-python-programming #  3
Tags: large, game, board game, two-player""" #  4
 #  5
import sys #  6
 #  7
# Constants used for displaying the board: #  8
EMPTY_SPACE = '.'  # A period is easier to count than a space. #  9
PLAYER_X = 'X' #  10
PLAYER_O = 'O' #  11
 #  12
# Note: Update displayBoard() & COLUMN_LABELS if BOARD_WIDTH is changed. #  13
BOARD_WIDTH = 7 #  14
BOARD_HEIGHT = 6 #  15
COLUMN_LABELS = ('1', '2', '3', '4', '5', '6', '7') #  16
assert len(COLUMN_LABELS) == BOARD_WIDTH #  17
 #  18
 #  19
def main(): #  20
   print("""Four in a Row, by Al Sweigart email@protected #  21
 #  22
Two players take turns dropping tiles into one of seven columns, trying #  23
to make four in a row horizontally, vertically, or diagonally. #  24
""") #  25
 #  26
   # Set up a new game: #  27
   gameBoard = getNewBoard() #  28
   playerTurn = PLAYER_X #  29
 #  30
   while True:  # Run a player's turn. #  31
       # Display the board and get player's move: #  32
       displayBoard(gameBoard) #  33
       playerMove = askForPlayerMove(playerTurn, gameBoard) #  34
       gameBoard[playerMove] = playerTurn #  35
 #  36
       # Check for a win or tie: #  37
       if isWinner(playerTurn, gameBoard): #  38
           displayBoard(gameBoard)  # Display the board one last time. #  39
           print('Player ' + playerTurn + ' has won!') #  40
           sys.exit() #  41
       elif isFull(gameBoard): #  42
           displayBoard(gameBoard)  # Display the board one last time. #  43
           print('There is a tie!') #  44
           sys.exit() #  45
 #  46
       # Switch turns to other player: #  47
       if playerTurn == PLAYER_X: #  48
           playerTurn = PLAYER_O #  49
       elif playerTurn == PLAYER_O: #  50
           playerTurn = PLAYER_X #  51
 #  52
 #  53
def getNewBoard(): #  54
   """Returns a dictionary that represents a Four in a Row board. #  55
 #  56
   The keys are (columnIndex, rowIndex) tuples of two integers, and the #  57
   values are one of the 'X', 'O' or '.' (empty space) strings.""" #  58
   board = {} #  59
   for columnIndex in range(BOARD_WIDTH): #  60
       for rowIndex in range(BOARD_HEIGHT): #  61
           board[(columnIndex, rowIndex)] = EMPTY_SPACE #  62
   return board #  63
 #  64
 #  65
def displayBoard(board): #  66
   """Display the board and its tiles on the screen.""" #  67
 #  68
   '''Prepare a list to pass to the format() string method for the #  69
   board template. The list holds all of the board's tiles (and empty #  70
   spaces) going left to right, top to bottom:''' #  71
   tileChars = [] #  72
   for rowIndex in range(BOARD_HEIGHT): #  73
       for columnIndex in range(BOARD_WIDTH): #  74
           tileChars.append(board[(columnIndex, rowIndex)]) #  75
 #  76
   # Display the board: #  77
   print(""" #  78
    1234567 #  79
   +-------+ #  80
   |{}{}{}{}{}{}{}| #  81
   |{}{}{}{}{}{}{}| #  82
   |{}{}{}{}{}{}{}| #  83
   |{}{}{}{}{}{}{}| #  84
   |{}{}{}{}{}{}{}| #  85
   |{}{}{}{}{}{}{}| #  86
   +-------+""".format(*tileChars)) #  87
 #  88
 #  89
def askForPlayerMove(playerTile, board): #  90
   """Let a player select a column on the board to drop a tile into. #  91
 #  92
   Returns a tuple of the (column, row) that the tile falls into.""" #  93
   while True:  # Keep asking player until they enter a valid move. #  94
       print('Player {}, enter a column or QUIT:'.format(playerTile)) #  95
       response = input('> ').upper().strip() #  96
 #  97
       if response == 'QUIT': #  98
           print('Thanks for playing!') #  99
            sys.exit() # 100
 # 101
        if response not in COLUMN_LABELS: # 102
            print('Enter a number from 1 to {}.'.format(BOARD_WIDTH)) # 103
            continue  # Ask player again for their move. # 104
 # 105
        columnIndex = int(response) - 1  # -1 for 0-based the index. # 106
 # 107
        # If the column is full, ask for a move again: # 108
        if board[(columnIndex, 0)] != EMPTY_SPACE: # 109
            print('That column is full, select another one.') # 110
            continue  # Ask player again for their move. # 111
 # 112
        # Starting from the bottom, find the first empty space. # 113
        for rowIndex in range(BOARD_HEIGHT - 1, -1, -1): # 114
            if board[(columnIndex, rowIndex)] == EMPTY_SPACE: # 115
                return (columnIndex, rowIndex) # 116
 # 117
 # 118
def isFull(board): # 119
    """Returns True if the `board` has no empty spaces, otherwise # 120
    returns False.""" # 121
    for rowIndex in range(BOARD_HEIGHT): # 122
        for columnIndex in range(BOARD_WIDTH): # 123
            if board[(columnIndex, rowIndex)] == EMPTY_SPACE: # 124
                return False  # Found an empty space, so return False. # 125
    return True  # All spaces are full. # 126
 # 127
 # 128
def isWinner(playerTile, board): # 129
    """Returns True if `playerTile` has four tiles in a row on `board`, # 130
    otherwise returns False.""" # 131
 # 132
    # Go through the entire board, checking for four-in-a-row: # 133
    for columnIndex in range(BOARD_WIDTH - 3): # 134
        for rowIndex in range(BOARD_HEIGHT): # 135
            # Check for horizontal four-in-a-row going right: # 136
            tile1 = board[(columnIndex, rowIndex)] # 137
            tile2 = board[(columnIndex + 1, rowIndex)] # 138
            tile3 = board[(columnIndex + 2, rowIndex)] # 139
            tile4 = board[(columnIndex + 3, rowIndex)] # 140
            if tile1 == tile2 == tile3 == tile4 == playerTile: # 141
                return True # 142
 # 143
    for columnIndex in range(BOARD_WIDTH): # 144
        for rowIndex in range(BOARD_HEIGHT - 3): # 145
            # Check for vertical four-in-a-row going down: # 146
            tile1 = board[(columnIndex, rowIndex)] # 147
            tile2 = board[(columnIndex, rowIndex + 1)] # 148
            tile3 = board[(columnIndex, rowIndex + 2)] # 149
            tile4 = board[(columnIndex, rowIndex + 3)] # 150
            if tile1 == tile2 == tile3 == tile4 == playerTile: # 151
                return True # 152
 # 153
    for columnIndex in range(BOARD_WIDTH - 3): # 154
        for rowIndex in range(BOARD_HEIGHT - 3): # 155
            # Check for four-in-a-row going right-down diagonal: # 156
            tile1 = board[(columnIndex, rowIndex)] # 157
            tile2 = board[(columnIndex + 1, rowIndex + 1)] # 158
            tile3 = board[(columnIndex + 2, rowIndex + 2)] # 159
            tile4 = board[(columnIndex + 3, rowIndex + 3)] # 160
            if tile1 == tile2 == tile3 == tile4 == playerTile: # 161
                return True # 162
 # 163
            # Check for four-in-a-row going left-down diagonal: # 164
            tile1 = board[(columnIndex + 3, rowIndex)] # 165
            tile2 = board[(columnIndex + 2, rowIndex + 1)] # 166
            tile3 = board[(columnIndex + 1, rowIndex + 2)] # 167
            tile4 = board[(columnIndex, rowIndex + 3)] # 168
            if tile1 == tile2 == tile3 == tile4 == playerTile: # 169
                return True # 170
    return False # 171
 # 172
 # 173
# If the program is run (instead of imported), run the game: # 174
if __name__ == '__main__': # 175
    main()  # 176
```

在输入源代码并运行几次之后，尝试对其进行实验性的修改。标有`(!)`的评论对你可以做的小改变有建议。你也可以自己想办法做到以下几点:

*   创建三排或五排变体。
*   做一个这个游戏的三人变种。
*   添加一个“通配符”牌，该牌在玩家回合后随机掉落，并且可以由任何一个玩家使用。
*   添加任一玩家都不能使用的“阻止”牌。

## 探索计划

试着找出下列问题的答案。尝试对代码进行一些修改，然后重新运行程序，看看这些修改有什么影响。

1.  如果把第 11 行的`PLAYER_O = 'O'`改成`PLAYER_O = 'X'`会怎么样？
2.  如果把 116 行的`return (columnIndex, rowIndex)`改成`return (columnIndex, 0)`会怎么样？
3.  如果把第 98 行的`response == 'QUIT'`改成`response != 'QUIT'`会怎么样？
4.  如果将第 72 行的`tileChars = []`改为`tileChars = {}`，会得到什么错误信息？