# #39 兰顿的蚂蚁

> 原文：<http://inventwithpython.com/bigbookpython/project39.html>

![](img/9d995d63aaead72cad01120081eb8f75.png)

兰顿的蚂蚁是二维网格上的元胞自动机模拟，类似于项目 13“康威的生命游戏”。在模拟中，一只“蚂蚁”从两种颜色之一的正方形开始。如果空间是第一种颜色，蚂蚁将它切换到第二种颜色，向右旋转 90 度，并向前移动一个空间。如果空间是第二种颜色，蚂蚁将它切换到第一种颜色，向左旋转 90 度，并向前移动一个空间。尽管规则非常简单，但模拟显示了复杂的突发行为。模拟可以在同一个空间中展示多只蚂蚁，当它们彼此相遇时，会产生有趣的互动。兰顿的蚂蚁是计算机科学家克里斯·兰顿在 1986 年发明的。更多关于朗顿蚂蚁的信息可以在`en.wikipedia.org/wiki/Langton%27s_ant`找到。

## 行动中的计划

图 39-1 显示了运行 `langtonsant.py` 时的输出。

![f39001](img/c444124258229015df798a1de6d50f2f.png)

:朗顿蚂蚁细胞自动机的催眠输出

## 它是如何工作的

这个程序使用了两种“方向”的含义一方面，代表每只蚂蚁的字典存储了基本方向:北、南、东、西。然而，向左或向右(或逆时针和顺时针，因为我们是从上面看蚂蚁)是一个*旋转方向*。蚂蚁应该根据它们所站的瓷砖向左转或向右转，所以第 78 到 100 行根据蚂蚁当前的基本方向和它们转向的方向设置了一个新的基本方向。

```py
"""Langton's Ant, by Al Sweigart email@protected #  1
A cellular automata animation. Press Ctrl-C to stop. #  2
More info: https://en.wikipedia.org/wiki/Langton%27s_ant #  3
This code is available at https://nostarch.com/big-book-small-python-programming #  4
Tags: large, artistic, bext, simulation""" #  5
 #  6
import copy, random, sys, time #  7
 #  8
try: #  9
   import bext #  10
except ImportError: #  11
   print('This program requires the bext module, which you') #  12
   print('can install by following the instructions at') #  13
   print('https://pypi.org/project/Bext/') #  14
   sys.exit() #  15
 #  16
# Set up the constants: #  17
WIDTH, HEIGHT = bext.size() #  18
# We can't print to the last column on Windows without it adding a #  19
# newline automatically, so reduce the width by one: #  20
WIDTH -= 1 #  21
HEIGHT -= 1  # Adjustment for the quit message at the bottom. #  22
 #  23
NUMBER_OF_ANTS = 10  # (!) Try changing this to 1 or 50. #  24
PAUSE_AMOUNT = 0.1  # (!) Try changing this to 1.0 or 0.0. #  25
 #  26
# (!) Try changing these to make the ants look different: #  27
ANT_UP = '^' #  28
ANT_DOWN = 'v' #  29
ANT_LEFT = '<' #  30
ANT_RIGHT = '>' #  31
 #  32
# (!) Try changing these colors to one of 'black', 'red', 'green', #  33
# 'yellow', 'blue', 'purple', 'cyan', or 'white'. (These are the only #  34
# colors that the bext module supports.) #  35
ANT_COLOR = 'red' #  36
BLACK_TILE = 'black' #  37
WHITE_TILE = 'white' #  38
 #  39
NORTH = 'north' #  40
SOUTH = 'south' #  41
EAST = 'east' #  42
WEST = 'west' #  43
 #  44
 #  45
def main(): #  46
   bext.fg(ANT_COLOR)  # The ants' color is the foreground color. #  47
   bext.bg(WHITE_TILE)  # Set the background to white to start. #  48
   bext.clear() #  49
 #  50
   # Create a new board data structure: #  51
   board = {'width': WIDTH, 'height': HEIGHT} #  52
 #  53
   # Create ant data structures: #  54
   ants = [] #  55
   for i in range(NUMBER_OF_ANTS): #  56
       ant = { #  57
           'x': random.randint(0, WIDTH - 1), #  58
           'y': random.randint(0, HEIGHT - 1), #  59
           'direction': random.choice([NORTH, SOUTH, EAST, WEST]), #  60
       } #  61
       ants.append(ant) #  62
 #  63
   # Keep track of which tiles have changed and need to be redrawn on #  64
   # the screen: #  65
   changedTiles = [] #  66
 #  67
   while True:  # Main program loop. #  68
       displayBoard(board, ants, changedTiles) #  69
       changedTiles = [] #  70
 #  71
       # nextBoard is what the board will look like on the next step in #  72
       # the simulation. Start with a copy of the current step's board: #  73
       nextBoard = copy.copy(board) #  74
 #  75
       # Run a single simulation step for each ant: #  76
       for ant in ants: #  77
           if board.get((ant['x'], ant['y']), False) == True: #  78
               nextBoard[(ant['x'], ant['y'])] = False #  79
               # Turn clockwise: #  80
               if ant['direction'] == NORTH: #  81
                   ant['direction'] = EAST #  82
               elif ant['direction'] == EAST: #  83
                   ant['direction'] = SOUTH #  84
               elif ant['direction'] == SOUTH: #  85
                   ant['direction'] = WEST #  86
               elif ant['direction'] == WEST: #  87
                   ant['direction'] = NORTH #  88
           else: #  89
               nextBoard[(ant['x'], ant['y'])] = True #  90
               # Turn counter clockwise: #  91
               if ant['direction'] == NORTH: #  92
                   ant['direction'] = WEST #  93
               elif ant['direction'] == WEST: #  94
                   ant['direction'] = SOUTH #  95
               elif ant['direction'] == SOUTH: #  96
                   ant['direction'] = EAST #  97
               elif ant['direction'] == EAST: #  98
                   ant['direction'] = NORTH #  99
            changedTiles.append((ant['x'], ant['y'])) # 100
 # 101
            # Move the ant forward in whatever direction it's facing: # 102
            if ant['direction'] == NORTH: # 103
                ant['y'] -= 1 # 104
            if ant['direction'] == SOUTH: # 105
                ant['y'] += 1 # 106
            if ant['direction'] == WEST: # 107
                ant['x'] -= 1 # 108
            if ant['direction'] == EAST: # 109
                ant['x'] += 1 # 110
 # 111
            # If the ant goes past the edge of the screen, # 112
            # it should wrap around to other side. # 113
            ant['x'] = ant['x'] % WIDTH # 114
            ant['y'] = ant['y'] % HEIGHT # 115
 # 116
            changedTiles.append((ant['x'], ant['y'])) # 117
 # 118
        board = nextBoard # 119
 # 120
 # 121
def displayBoard(board, ants, changedTiles): # 122
    """Displays the board and ants on the screen. The changedTiles # 123
    argument is a list of (x, y) tuples for tiles on the screen that # 124
    have changed and need to be redrawn.""" # 125
 # 126
    # Draw the board data structure: # 127
    for x, y in changedTiles: # 128
        bext.goto(x, y) # 129
        if board.get((x, y), False): # 130
            bext.bg(BLACK_TILE) # 131
        else: # 132
            bext.bg(WHITE_TILE) # 133
 # 134
        antIsHere = False # 135
        for ant in ants: # 136
            if (x, y) == (ant['x'], ant['y']): # 137
                antIsHere = True # 138
                if ant['direction'] == NORTH: # 139
                    print(ANT_UP, end='') # 140
                elif ant['direction'] == SOUTH: # 141
                    print(ANT_DOWN, end='') # 142
                elif ant['direction'] == EAST: # 143
                    print(ANT_LEFT, end='') # 144
                elif ant['direction'] == WEST: # 145
                    print(ANT_RIGHT, end='') # 146
                break # 147
        if not antIsHere: # 148
            print(' ', end='') # 149
 # 150
    # Display the quit message at the bottom of the screen: # 151
    bext.goto(0, HEIGHT) # 152
    bext.bg(WHITE_TILE) # 153
    print('Press Ctrl-C to quit.', end='') # 154
 # 155
    sys.stdout.flush()  # (Required for bext-using programs.) # 156
    time.sleep(PAUSE_AMOUNT) # 157
 # 158
 # 159
# If this program was run (instead of imported), run the game: # 160
if __name__ == '__main__': # 161
    try: # 162
        main() # 163
    except KeyboardInterrupt: # 164
        print("Langton's Ant, by Al Sweigart email@protected") # 165
        sys.exit()  # When Ctrl-C is pressed, end the program.  # 166
```

在输入源代码并运行几次之后，尝试对其进行实验性的修改。标有`(!)`的评论对你可以做的小改变有建议。你也可以自己想办法做到以下几点:

*   让玩家从文本文件中加载并保存棋盘的状态。
*   使用新的移动规则创建额外的平铺状态，看看会出现什么行为。
*   为兰顿的蚂蚁实现维基百科文章中建议的一些想法。

## 探索计划

试着找出下列问题的答案。尝试对代码进行一些修改，然后重新运行程序，看看这些修改有什么影响。

1.  如果把 149 行的`print(' ', end='')`改成`print('.', end='')`会怎么样？
2.  如果把 106 行的`ant['y'] += 1`改成`ant['y'] -= 1`会怎么样？
3.  如果把第 79 行的`nextBoard[(ant['x'], ant['y'])] = False`改成`nextBoard[(ant['x'], ant['y'])] = True`会怎么样？
4.  如果把第 21 行的`WIDTH -= 1`改成`WIDTH -= 40`会怎么样？
5.  如果把 119 行的`board = nextBoard`改成`board = board`会怎么样？