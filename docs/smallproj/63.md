# #62 旋转立方体

> 原文：<http://inventwithpython.com/bigbookpython/project62.html>

![](img/9d995d63aaead72cad01120081eb8f75.png)

这个项目的特点是使用三角函数的 3D 立方体旋转动画。您可以在自己的动画程序中修改 3D 点旋转数学和`line()`功能。

虽然我们将用来绘制立方体的块文本字符看起来不像细而直的线，但这种绘制被称为*线框模型*，因为它只渲染物体表面的边缘。[图 62-1](#calibre_link-347) 显示了立方体和 icosphere 的线框模型，icosphere 是一个由三角形组成的粗糙球体。

![f62001](img/e7939487302529e512bc4b0e074ff1d3.png)

:立方体(左)和 icosphere(右)的线框模型

## 行动中的计划

图 62-2 显示了运行 `rotatingcube.py` 时的输出。

![f62002](img/f63f730478b6e442ca208039940b8d2b.png)

:程序绘制到屏幕上的线框立方体

## 它是如何工作的

这个算法有两个主要部分:函数`line()`和函数`rotatePoint()`。立方体有八个点，每个角一个。程序将这些角存储为`CUBE_CORNERS`列表中的`(` `x` `,` `y` `,` `z` `)`元组。这些点也定义了立方体边缘线的连接。当所有的点都向同一个方向旋转相同的量时，它们会产生立方体旋转的错觉。

```py
"""Rotating Cube, by Al Sweigart email@protected #  1
A rotating cube animation. Press Ctrl-C to stop. #  2
This code is available at https://nostarch.com/big-book-small-python-programming #  3
Tags: large, artistic, math""" #  4
 #  5
# This program MUST be run in a Terminal/Command Prompt window. #  6
 #  7
import math, time, sys, os #  8
 #  9
# Set up the constants: #  10
PAUSE_AMOUNT = 0.1  # Pause length of one-tenth of a second. #  11
WIDTH, HEIGHT = 80, 24 #  12
SCALEX = (WIDTH - 4) // 8 #  13
SCALEY = (HEIGHT - 4) // 8 #  14
# Text cells are twice as tall as they are wide, so set scaley: #  15
SCALEY *= 2 #  16
TRANSLATEX = (WIDTH - 4) // 2 #  17
TRANSLATEY = (HEIGHT - 4) // 2 #  18
 #  19
# (!) Try changing this to '#' or '*' or some other character: #  20
LINE_CHAR = chr(9608)  # Character 9608 is a solid block. #  21
 #  22
# (!) Try setting two of these values to zero to rotate the cube only #  23
# along a single axis: #  24
X_ROTATE_SPEED = 0.03 #  25
Y_ROTATE_SPEED = 0.08 #  26
Z_ROTATE_SPEED = 0.13 #  27
 #  28
# This program stores XYZ coordinates in lists, with the X coordinate #  29
# at index 0, Y at 1, and Z at 2\. These constants make our code more #  30
# readable when accessing the coordinates in these lists. #  31
X = 0 #  32
Y = 1 #  33
Z = 2 #  34
 #  35
 #  36
def line(x1, y1, x2, y2): #  37
   """Returns a list of points in a line between the given points. #  38
 #  39
   Uses the Bresenham line algorithm. More info at: #  40
   https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm""" #  41
   points = []  # Contains the points of the line. #  42
   # "Steep" means the slope of the line is greater than 45 degrees or #  43
   # less than -45 degrees: #  44
 #  45
   # Check for the special case where the start and end points are #  46
   # certain neighbors, which this function doesn't handle correctly, #  47
   # and return a hard coded list instead: #  48
   if (x1 == x2 and y1 == y2 + 1) or (y1 == y2 and x1 == x2 + 1): #  49
       return [(x1, y1), (x2, y2)] #  50
 #  51
   isSteep = abs(y2 - y1) > abs(x2 - x1) #  52
   if isSteep: #  53
       # This algorithm only handles non-steep lines, so let's change #  54
       # the slope to non-steep and change it back later. #  55
       x1, y1 = y1, x1  # Swap x1 and y1 #  56
       x2, y2 = y2, x2  # Swap x2 and y2 #  57
   isReversed = x1 > x2  # True if the line goes right-to-left. #  58
 #  59
   if isReversed:  # Get the points on the line going right-to-left. #  60
       x1, x2 = x2, x1  # Swap x1 and x2 #  61
       y1, y2 = y2, y1  # Swap y1 and y2 #  62
 #  63
       deltax = x2 - x1 #  64
       deltay = abs(y2 - y1) #  65
       extray = int(deltax / 2) #  66
       currenty = y2 #  67
       if y1 < y2: #  68
           ydirection = 1 #  69
       else: #  70
           ydirection = -1 #  71
       # Calculate the y for every x in this line: #  72
       for currentx in range(x2, x1 - 1, -1): #  73
           if isSteep: #  74
               points.append((currenty, currentx)) #  75
           else: #  76
               points.append((currentx, currenty)) #  77
           extray -= deltay #  78
           if extray <= 0:  # Only change y once extray <= 0. #  79
               currenty -= ydirection #  80
               extray += deltax #  81
   else:  # Get the points on the line going left to right. #  82
       deltax = x2 - x1 #  83
       deltay = abs(y2 - y1) #  84
       extray = int(deltax / 2) #  85
       currenty = y1 #  86
       if y1 < y2: #  87
           ydirection = 1 #  88
       else: #  89
           ydirection = -1 #  90
       # Calculate the y for every x in this line: #  91
       for currentx in range(x1, x2 + 1): #  92
           if isSteep: #  93
               points.append((currenty, currentx)) #  94
           else: #  95
               points.append((currentx, currenty)) #  96
           extray -= deltay #  97
           if extray < 0:  # Only change y once extray < 0. #  98
               currenty += ydirection #  99
                extray += deltax # 100
    return points # 101
 # 102
 # 103
def rotatePoint(x, y, z, ax, ay, az): # 104
    """Returns an (x, y, z) tuple of the x, y, z arguments rotated. # 105
 # 106
    The rotation happens around the 0, 0, 0 origin by angles # 107
    ax, ay, az (in radians). # 108
        Directions of each axis: # 109
         -y # 110
          | # 111
          +-- +x # 112
         / # 113
        +z # 114
    """ # 115
 # 116
    # Rotate around x axis: # 117
    rotatedX = x # 118
    rotatedY = (y * math.cos(ax)) - (z * math.sin(ax)) # 119
    rotatedZ = (y * math.sin(ax)) + (z * math.cos(ax)) # 120
    x, y, z = rotatedX, rotatedY, rotatedZ # 121
 # 122
    # Rotate around y axis: # 123
    rotatedX = (z * math.sin(ay)) + (x * math.cos(ay)) # 124
    rotatedY = y # 125
    rotatedZ = (z * math.cos(ay)) - (x * math.sin(ay)) # 126
    x, y, z = rotatedX, rotatedY, rotatedZ # 127
 # 128
    # Rotate around z axis: # 129
    rotatedX = (x * math.cos(az)) - (y * math.sin(az)) # 130
    rotatedY = (x * math.sin(az)) + (y * math.cos(az)) # 131
    rotatedZ = z # 132
 # 133
    return (rotatedX, rotatedY, rotatedZ) # 134
 # 135
 # 136
def adjustPoint(point): # 137
    """Adjusts the 3D XYZ point to a 2D XY point fit for displaying on # 138
    the screen. This resizes this 2D point by a scale of SCALEX and # 139
    SCALEY, then moves the point by TRANSLATEX and TRANSLATEY.""" # 140
    return (int(point[X] * SCALEX + TRANSLATEX), # 141
            int(point[Y] * SCALEY + TRANSLATEY)) # 142
 # 143
 # 144
"""CUBE_CORNERS stores the XYZ coordinates of the corners of a cube. # 145
The indexes for each corner in CUBE_CORNERS are marked in this diagram: # 146
      0---1 # 147
     /|  /| # 148
    2---3 | # 149
    | 4-|-5 # 150
    |/  |/ # 151
    6---7""" # 152
CUBE_CORNERS = [[-1, -1, -1], # Point 0 # 153
                [ 1, -1, -1], # Point 1 # 154
                [-1, -1,  1], # Point 2 # 155
                [ 1, -1,  1], # Point 3 # 156
                [-1,  1, -1], # Point 4 # 157
                [ 1,  1, -1], # Point 5 # 158
                [-1,  1,  1], # Point 6 # 159
                [ 1,  1,  1]] # Point 7 # 160
# rotatedCorners stores the XYZ coordinates from CUBE_CORNERS after # 161
# they've been rotated by rx, ry, and rz amounts: # 162
rotatedCorners = [None, None, None, None, None, None, None, None] # 163
# Rotation amounts for each axis: # 164
xRotation = 0.0 # 165
yRotation = 0.0 # 166
zRotation = 0.0 # 167
 # 168
try: # 169
    while True:  # Main program loop. # 170
        # Rotate the cube along different axes by different amounts: # 171
        xRotation += X_ROTATE_SPEED # 172
        yRotation += Y_ROTATE_SPEED # 173
        zRotation += Z_ROTATE_SPEED # 174
        for i in range(len(CUBE_CORNERS)): # 175
            x = CUBE_CORNERS[i][X] # 176
            y = CUBE_CORNERS[i][Y] # 177
            z = CUBE_CORNERS[i][Z] # 178
            rotatedCorners[i] = rotatePoint(x, y, z, xRotation, # 179
                yRotation, zRotation) # 180
 # 181
        # Get the points of the cube lines: # 182
        cubePoints = [] # 183
        for fromCornerIndex, toCornerIndex in ((0, 1), (1, 3), (3, 2), (2, 0), (0, 4), (1, 5), (2, 6), (3, 7), (4, 5), (5, 7), (7, 6), (6, 4)): # 184
            fromX, fromY = adjustPoint(rotatedCorners[fromCornerIndex]) # 185
            toX, toY = adjustPoint(rotatedCorners[toCornerIndex]) # 186
            pointsOnLine = line(fromX, fromY, toX, toY) # 187
            cubePoints.extend(pointsOnLine) # 188
 # 189
        # Get rid of duplicate points: # 190
        cubePoints = tuple(frozenset(cubePoints)) # 191
 # 192
        # Display the cube on the screen: # 193
        for y in range(HEIGHT): # 194
            for x in range(WIDTH): # 195
                if (x, y) in cubePoints: # 196
                    # Display full block: # 197
                    print(LINE_CHAR, end='', flush=False) # 198
                else: # 199
                    # Display empty space: # 200
                    print(' ', end='', flush=False) # 201
            print(flush=False) # 202
        print('Press Ctrl-C to quit.', end='', flush=True) # 203
 # 204
        time.sleep(PAUSE_AMOUNT)  # Pause for a bit. # 205
 # 206
        # Clear the screen: # 207
        if sys.platform == 'win32': # 208
            os.system('cls')  # Windows uses the cls command. # 209
        else: # 210
            os.system('clear')  # macOS and Linux use the clear command. # 211
 # 212
except KeyboardInterrupt: # 213
    print('Rotating Cube, by Al Sweigart email@protected') # 214
    sys.exit()  # When Ctrl-C is pressed, end the program.  # 215
```

在输入源代码并运行几次之后，尝试对其进行实验性的修改。标有`(!)`的评论对你可以做的小改变有建议。你也可以自己想办法做到以下几点:

*   修改`CUBE_CORNERS`和第 184 行的元组，创建不同的线框模型，如金字塔和扁平六边形。
*   将`CUBE_CORNERS`的坐标增加`1.5`，使立方体围绕屏幕中心旋转，而不是围绕自己的中心旋转。

## 探索计划

试着找出下列问题的答案。尝试对代码进行一些修改，然后重新运行程序，看看这些修改有什么影响。

1.  如果删除或注释掉第 208 到 211 行会发生什么？
2.  如果把 184 行的元组改成`<((0, 1), (1, 3), (3, 2), (2, 0), (0,4), (4, 5), (5, 1))>`会怎么样？