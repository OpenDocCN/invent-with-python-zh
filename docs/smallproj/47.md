# # 4600 万骰子滚动统计模拟器

> 原文：<http://inventwithpython.com/bigbookpython/project46.html>

![](img/9d995d63aaead72cad01120081eb8f75.png)

当你掷出两个六面骰子时，有 17%的机会掷出 7。这比掷出 2 的几率好得多:只有 3%。这是因为只有一种掷骰子的组合给你 2(当两个骰子都掷出 1 时发生的组合)，但许多组合加起来是 7:1 和 6，2 和 5，3 和 4，等等。

但是当你掷出三个骰子呢？还是四个？还是 1000？你可以用数学方法计算理论概率，或者你可以让计算机掷骰子一百万次，凭经验算出它们。这个程序采用了后一种方法。在这个程序中，你告诉计算机掷骰子一百万次并记住结果。然后，它显示每笔金额的百分比机会。

这个程序做了大量的计算，但是计算本身并不难理解。

## 行动中的计划

当您运行 `milliondicestats.py` 时，输出将如下所示:

```py
Million Dice Roll Statistics Simulator
By Al Sweigart email@protected

Enter how many six-sided dice you want to roll:
> 2
Simulating 1,000,000 rolls of 2 dice...
36.2% done...
73.4% done...
TOTAL - ROLLS - PERCENTAGE
  2 - 27590 rolls - 2.8%
  3 - 55730 rolls - 5.6%
  4 - 83517 rolls - 8.4%
  5 - 111526 rolls - 11.2%
  6 - 139015 rolls - 13.9%
  7 - 166327 rolls - 16.6%
  8 - 139477 rolls - 13.9%
  9 - 110268 rolls - 11.0%
  10 - 83272 rolls - 8.3%
  11 - 55255 rolls - 5.5%
  12 - 28023 rolls - 2.8%
```

## 它是如何工作的

我们通过在第 30 行调用`random.randint(1, 6)`来模拟单个六面骰子的滚动。这将返回一个介于`1`和`6`之间的随机数，无论掷出多少骰子，该随机数都会被添加到累计总数中。`random.randint()`函数具有均匀分布，这意味着每个数字都像其他数字一样有可能被返回。

程序用`results`字典存储这次掷骰的结果。这个字典的关键字是每个可能的掷骰子总数，值是这个总数遇到的次数。为了获得频率百分比，我们将总数遇到的次数除以 1，000，000(在该模拟中掷骰子的次数)并乘以 100(以获得 0.0 和 100.0 之间的百分比，而不是 0.0 和 1.0)。通过做一些代数运算，我们可以算出，这与我们在第 37 行所做的将遭遇次数除以 10，000 是一样的。

```py
"""Million Dice Roll Statistics Simulator #  1
By Al Sweigart email@protected #  2
A simulation of one million dice rolls. #  3
This code is available at https://nostarch.com/big-book-small-python-programming #  4
Tags: tiny, beginner, math, simulation""" #  5
 #  6
import random, time #  7
 #  8
print('''Million Dice Roll Statistics Simulator #  9
By Al Sweigart email@protected # 10
 # 11
Enter how many six-sided dice you want to roll:''') # 12
numberOfDice = int(input('> ')) # 13
 # 14
# Set up a dictionary to store the results of each dice roll: # 15
results = {} # 16
for i in range(numberOfDice, (numberOfDice * 6) + 1): # 17
    results[i] = 0 # 18
 # 19
# Simulate dice rolls: # 20
print('Simulating 1,000,000 rolls of {} dice...'.format(numberOfDice)) # 21
lastPrintTime = time.time() # 22
for i in range(1000000): # 23
    if time.time() > lastPrintTime + 1: # 24
        print('{}% done...'.format(round(i / 10000, 1))) # 25
        lastPrintTime = time.time() # 26
 # 27
    total = 0 # 28
    for j in range(numberOfDice): # 29
        total = total + random.randint(1, 6) # 30
    results[total] = results[total] + 1 # 31
 # 32
# Display results: # 33
print('TOTAL - ROLLS - PERCENTAGE') # 34
for i in range(numberOfDice, (numberOfDice * 6) + 1): # 35
    roll = results[i] # 36
    percentage = round(results[i] / 10000, 1) # 37
    print(' {} - {} rolls - {}%'.format(i, roll, percentage))  # 38
```

在输入源代码并运行几次之后，尝试对其进行实验性的修改。你也可以自己想办法做到以下几点:

*   尝试掷出 8 面、10 面、12 面或 20 面骰子。
*   尝试模拟双面抛硬币。

## 探索计划

试着找出下列问题的答案。尝试对代码进行一些修改，然后重新运行程序，看看这些修改有什么影响。

1.  如果把第 24 行的`lastPrintTime + 1`改成`lastPrintTime + 2`会怎么样？
2.  如果删除或注释掉第 31 行的`results[total] = results[total] + 1`，会导致什么 bug？
3.  如果用户键入字母而不是数字来表示要掷出的六面骰子的数量，会出现什么错误？